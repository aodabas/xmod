<!-- ------------------------------------------------------------------- -->
<!--                                                                     -->
<!--  gp2obj.xml            XMod documentation            Chris Wensley  -->
<!--                                                        & Murat Alp  -->
<!--  Copyright (C) 1996-2018, Chris Wensley et al,                      --> 
<!--  School of Computer Science, Bangor University, U.K.                --> 
<!--                                                                     -->
<!-- ------------------------------------------------------------------- -->

<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="chap-gp2obj">

<Heading>2d-groups : crossed modules and cat1-groups</Heading>

<Index>2d-domain</Index>
<Index>2d-group</Index>
The term <E>2d-group</E> refers to a set of equivalent categories 
of which the most common are the categories of 
<E>crossed modules</E>; <E>cat1-groups</E>; and <E>group-groupoids</E>, 
all of which involve a pair of groups. 

<Section Label="sect-constructions">
<Heading>Constructions for crossed modules</Heading>

<Index>crossed module</Index>
A crossed module (of groups)  <M>\mathcal{X} = (\partial : S \to R )</M> 
consists of a group homomorphism <M>\partial </M>, 
called the <E>boundary</E> of <M>\mathcal{X}</M>, 
with <E>source</E> <M>S</M>  and <E>range</E> <M>R</M>. 
The group <M>R</M> acts on itself by conjugation, and on <M>S</M> by an action 
<M>\alpha : R \to {\rm Aut}(S)</M> such that,  
for all <M>s,s_1,s_2 \in S</M>  and  <M>r \in R</M>,
<Display>
{\bf XMod\ 1}  :   \partial(s^r) 
   = r^{-1} (\partial s) r
   = (\partial s)^r,
\qquad
{\bf XMod\ 2}  :   s_1^{\partial s_2} 
   = s_2^{-1}s_1 s_2
   = {s_1}^{s_2}.
</Display> 
When only the first of these axioms is satisfied, the resulting structure is 
a <E>pre-crossed module</E> 
(see section <Ref Sect="sect-precrossed-modules" />).
(Much of the literature on crossed modules uses left actions, 
but we have chosen to use right actions in this package 
since that is the standard choice for group actions in &GAP;.) 
<P/>
The kernel of  <M>\partial</M>  is abelian.
<P/>
There are a variety of constructors for crossed modules, 
described in the following sections. 

<ManSection>
   <Oper Name="XModByNormalSubgroup"
         Arg="G N" />
<Description>
A <E>conjugation crossed module</E> is the inclusion of a normal subgroup  
<M>S \unlhd R</M>, where <M>R</M> acts on <M>S</M> by conjugation.
</Description>
</ManSection>
<Example>
<![CDATA[
gap> s4 := Group( (1,2), (2,3), (3,4) );; 
gap> a4 := Subgroup( s4, [ (1,2,3), (2,3,4) ] );; 
gap> SetName(s4,"s4");  SetName(a4,"a4"); 
gap> X4 := XModByNormalSubgroup( s4, a4 );
[a4->s4]
]]>
</Example>

<ManSection>
   <Oper Name="XModByAutomorphismGroup"
         Arg="grp" />
   <Oper Name="XModByInnerAutomorphismGroup"
         Arg="grp" />
   <Oper Name="XModByGroupOfAutomorphisms"
         Arg="grp autgrp" />
<Description>
An <E>automorphism crossed module</E> has as range a subgroup <M>R</M>
of the automorphism group  Aut<M>(S)</M>  of  <M>S</M>
which contains the inner automorphism group of <M>S</M>.
The boundary maps <M>s \in S</M> to the inner automorphism of <M>S</M> 
by <M>s</M>.
<Index>display a 2d-group</Index>
The <C>Display</C> function may be used to print details of 2d-groups.

</Description>
</ManSection>
<Example>
<![CDATA[
gap> c5 := Group( (5,6,7,8,9) );;
gap> SetName( c5, "c5" );
gap> X5 := XModByAutomorphismGroup( c5 );
[c5 -> Aut(c5)] 
gap> Display( X5 );
Crossed module [c5->Aut(c5)] :- 
: Source group c5 has generators:
  [ (5,6,7,8,9) ]
: Range group Aut(c5) has generators:
  [ GroupHomomorphismByImages( c5, c5, [ (5,6,7,8,9) ], [ (5,7,9,6,8) ] ) ]
: Boundary homomorphism maps source generators to:
  [ IdentityMapping( c5 ) ]
: Action homomorphism maps range generators to automorphisms:
  GroupHomomorphismByImages( c5, c5, [ (5,6,7,8,9) ], 
[ (5,7,9,6,8) ] ) --> { source gens --> [ (5,7,9,6,8) ] }
  This automorphism generates the group of automorphisms.
]]>
</Example>

<ManSection>
   <Oper Name="XModByTrivialAction"
         Arg="bdy" />
<Description>
A <E>trivial action crossed module</E>  <M>(\partial : S \to R)</M>
has  <M>s^r = s</M>  for all  <M>s \in S, \; r \in R</M>,  
the source is abelian and the image lies in the centre of the range.
</Description>
</ManSection>
<Example>
<![CDATA[
gap> c4 := Group( (6,7,8,9) );; 
gap> SetName( c4, "c4" ); 
gap> bdy54 := GroupHomomorphismByImages( c5, c4, [ (1,2,3,4,5) ], [ () ] );; 
gap> X45 := XModByTrivialAction( bdy54 );; 
gap> Display( X45 );
Crossed module [c5->c4] :- 
: Source group c5 has generators:
  [ (5,6,7,8,9) ]
: Range group c4 has generators:
  [ (1,2,3,4) ]
: Boundary homomorphism maps source generators to:
  [ () ]
  The automorphism group is trivial
]]>
</Example>

<ManSection>
   <Oper Name="XModByCentralExtension"
         Arg="bdy" />
<Description>
A <E>central extension crossed module</E> has as boundary a surjection
<M>\partial : S \to R</M>, with central kernel,
where <M>r \in R</M> acts on <M>S</M> by conjugation 
with <M>\partial^{-1}r</M>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> gen23 := [ (4,5,6)(7,9,8), (2,7,3,4)(5,8,9,6) ];; 
gap> sl23 := Group( gen23 );; 
gap> SetName( sl23, "sl23" ); 
gap> im23 := [ (1,2,3), (1,2)(3,4) ];;
gap> surj23 := GroupHomomorphismByImages( sl23, a4, gen23, im23 );; 
gap> X23 := XModByCentralExtension( surj23 );; 
gap> Display(X23);
Crossed module [sl23->a4] :- 
: Source group sl23 has generators:
  [ (4,5,6)(7,9,8), (2,7,3,4)(5,8,9,6) ]
: Range group has generators:
  [ (1,2,3), (2,3,4) ]
: Boundary homomorphism maps source generators to:
  [ (1,2,3), (1,2)(3,4) ]
: Action homomorphism maps range generators to automorphisms:
  (1,2,3) --> { source gens --> [ (4,5,6)(7,9,8), (2,9,3,5)(4,6,7,8) ] }
  (2,3,4) --> { source gens --> [ (2,9,4)(3,5,7), (2,8,3,6)(4,9,7,5) ] }
  These 2 automorphisms generate the group of automorphisms.
]]>
</Example>

<ManSection>
   <Oper Name="XModByBoundaryAndAction"
         Arg="bdy act" />
<Description>
This operation may be used when the boundary and action homomorphisms 
are known.  
In the example the boundary maps <M>C_{12} \times C_{12}</M> to <M>C_{12}</M>, 
and the action flips the two factors in the source. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> n := 12;;
gap> cn := CyclicGroup( n );; 
gap> c := cn.1;;
gap> cnn := DirectProduct( cn, cn );; 
gap> a := cnn.1;;  b := cnn.4;; 
gap> bdy := GroupHomomorphismByImages( cnn, cn, [a,b], [c^2,c^2] );; 
gap> twist := GroupHomomorphismByImages( cnn, cnn, [a,b], [b,a] );; 
gap> act := GroupHomomorphismByImages( cn, Group( twist ), [c], [twist] );; 
gap> Xn := XModByBoundaryAndAction( bdy, act );;
gap> Display( Xn );  
Crossed module :- 
: Source group has generators:
  [ f1, f2, f3, f4, f5, f6 ]
: Range group has generators:
  [ f1, f2, f3 ]
: Boundary homomorphism maps source generators to:
  [ f2, f3, f3^2, f2, f3, f3^2 ]
: Action homomorphism maps range generators to automorphisms:
  f1 --> { source gens --> [ f4, f5, f6, f1, f2, f3 ] }
  f2 --> { source gens --> [ f1, f2, f3, f4, f5, f6 ] }
  f3 --> { source gens --> [ f1, f2, f3, f4, f5, f6 ] }
  These 3 automorphisms generate the group of automorphisms.
]]>
</Example>

<ManSection>
   <Oper Name="XModByAbelianModule"
         Arg="abmod" />
<Description>
A <E>crossed abelian module</E> has an abelian module as source
and the zero map as boundary. 
For an example see the section on abelian modules (<Ref Sect="sect-abmod" />). 
<P/>
</Description>
</ManSection>

<ManSection>
   <Meth Name="DirectProductOp"
         Arg="L X1" Label="for crossed modules" />
<Description>
The direct product  <M>\mathcal{X}_{1} \times \mathcal{X}_{2}</M>
of two crossed modules has source  <M>S_1 \times S_2</M>,
range  <M>R_1 \times R_2</M>  and boundary
<M>\partial_1 \times \partial_2</M>,  with  <M>R_1,\ R_2</M>  acting
trivially on  <M>S_2,\ S_1</M>  respectively.
<P/> 
Since <C>DirectProduct</C> is a global function which only accepts groups, 
it is necessary to provide an "other method" for the operation 
<C>DirectProductOp</C> which, as usual, takes as parameters a list of 
crossed modules, followed by the first of these: 
<C>DirectProductOp([X1,X2],X1).</C> 
Lists with more than two crossed modules are not yet allowed. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> DirectProductOp( [ X4, X5 ], X4 );     
[a4xc5->s4xAut(c5)]
]]>
</Example>

<ManSection>
   <Func Name="XMod"
         Arg="args" />
<Description>
The global function <C>XMod</C> calls one of the previous seven 
standard constructions, as well as other options to be described later. 
The example constructs the direct square of the crossed module <C>Xn</C> 
constructed by <Ref Oper="XModByBoundaryAndAction"/>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> XMod( [ Xn, Xn ], Xn );
[Group( [ f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12 ] )->Group( 
[ f1, f2, f3, f4, f5, f6 ] )]
]]>
</Example>

</Section>


<Section Label="sect-attributes-xmod">
<Heading>Attributes of crossed modules</Heading>

The following attributes are used in the construction of
a crossed module <C>X0</C>, and in later computations. 
<P/>
<Example>
<![CDATA[
gap> KnownAttributesOfObject( X5 );
[ "Name", "Range", "Source", "Boundary", "XModAction", 
  "IsomorphismPerm2DimensionalGroup" ]
]]>
</Example>

<ManSection>
   <Attr Name="Boundary"
         Arg="X0" Label="for crossed modules of groups" />
   <Attr Name="Source"
         Arg="X0" Label="for crossed modules of groups" />
   <Attr Name="Range"
         Arg="X0" Label="for crossed modules of groups" />
<Description> 
The boundary map <M>\partial : S \to R</M> is the 
<C>Boundary(X0)</C> of <C>X0</C>,  
a group homomorphism from <C>Source(X0)</C>, <M>S</M>, 
to <C>Range(X0)</C>, <M>R</M>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Boundary( X23 );
[ (4,5,6)(7,9,8), (2,7,3,4)(5,8,9,6) ] -> [ (1,2,3), (1,2)(3,4) ]
]]>
</Example>

<ManSection>
   <Attr Name="XModAction"
         Arg="X0" Label="for crossed modules of groups" />
   <Oper Name="ImageElmXModAction"
         Arg="X0, s, r" />
<Description>
<C>XModAction(X0)</C> is a homomorphism from the range <M>R</M> 
to a group of automorphisms of <C>X0</C>. 
<P/>
<Index>AutoGroup</Index> 
(Up until version 2.63 there was an additional attribute <C>AutoGroup</C>, 
the range of <C>XModAction(X0)</C>.) 
<P/> 
The command <C>ImageElmXModAction(s,r)</C> 
returns the element <M>s^r</M> given by <C>XModAction(X0)</C>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> a := GeneratorsOfGroup( Range( X5 ) )[1]^2; 
[ (5,6,7,8,9) ] -> [ (5,9,8,7,6) ]
gap> ImageElmXModAction( X5, (5,9,8,7,6), a );
(5,6,7,8,9)
]]>
</Example>

<ManSection>
   <Meth Name="Size"
         Arg="X0" Label="for 2d-groups" />
   <Attr Name="Name"
         Arg="X0" Label="for 2d-groups" />
   <Attr Name="IdGroup"
         Arg="X0" Label="for 2d-groups" />
   <Attr Name="StructureDescription"
         Arg="X0" Label="for 2d-groups" />
<Description>
<C>Size(X0)</C> returns the two-element list <C>[Size(S),Size(R)]</C>. 
<P/> 
<C>Name(X0)</C> returns the two-element list <C>[Name(S),Name(R)]</C>. 
<P/> 
<C>IdGroup(X0)</C> returns the two-element list <C>[IdGroup(S),IdGroup(R)]</C>,
if these both exist. 
<P/> 
<C>StructureDescription(X0)</C> returns the two-element list of the 
descriptions of the source and target. 
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Size( X4 );
[ 12, 24 ]
gap> Name( X4 );
"[a4->s4]"
gap> IdGroup( X4 );
[ [ 12, 3 ], [ 24, 12 ] ]
gap> StructureDescription( X4 );
[ "A4", "S4" ]
]]>
</Example>


<ManSection>
   <Attr Name="ExternalSetXMod"
         Arg="X0" />
<Description>
The <Ref Attr="ExternalSetXMod"/> for a crossed module is the source group considered as a G-set of the range group using the crossed module action. 
<P/> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> ext := ExternalSetXMod( X5 ); 
<xset:[ (), (5,6,7,8,9), (5,7,9,6,8), (5,8,6,9,7), (5,9,8,7,6) ]>
gap> Orbits( ext );
[ [ () ], [ (5,6,7,8,9), (5,7,9,6,8), (5,9,8,7,6), (5,8,6,9,7) ] ]
]]>
</Example>

Chapter <Ref Chap="chap-isclnc" /> contains functions for quotient 
crossed modules; centre of a crossed module; 
commutator and derived sub-crossed modules; etc. 
<P/> 

</Section>



<Section Label="sect-properties-xmod">
<Heading>Properties of crossed modules</Heading>


<Index>Is2DimensionalDomain</Index>
<Index>Is2DimensionalGroup</Index>
<Index>IsTrivialAction2DimensionalGroup</Index>
<Index>IsNormalSubgroup2DimensionalGroup</Index>
<Index>IsCentralExtension2DimensionalGroup</Index>
<Index>IsAutomorphismGroup2DimensionalGroup</Index>
<Index>IsAbelianModule2DimensionalGroup</Index>

The underlying category structures for the objects constructed in this 
chapter follow the sequence <C>Is2DimensionalDomain</C>; 
<C>Is2DimensionalMagma</C>; <C>Is2DimensionalMagmaWithOne</C>; 
<C>Is2DimensionalMagmaWithInverses</C>, 
mirroring the situation for (one-dimensional) groups. 
From these we construct <C>Is2DimensionalSemigroup</C>, 
<C>Is2DimensionalMonoid</C> and <C>Is2DimensionalGroup</C>. 
<P/>
There are then a variety of properties associated with crossed modules, 
starting with <C>IsPreXMod</C> and <C>IsXMod</C>. 
<P/> 
<Example>
<![CDATA[
gap> KnownPropertiesOfObject( X4 );
[ "IsEmpty", "IsTrivial", "IsNonTrivial", "IsFinite", 
  "CanEasilyCompareElements", "CanEasilySortElements", "IsDuplicateFree", 
  "IsGeneratorsOfSemigroup", "IsPreXModDomain", "IsPerm2DimensionalGroup", 
  "IsPreXMod", "IsXMod", "IsNormalSubgroup2DimensionalGroup" ]
gap> RepresentationsOfObject( X4 );
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsPreXModObj" ]
]]>
</Example>

<ManSection>
   <Prop Name="IsXMod"
         Arg="X0" />
   <Prop Name="IsPreXMod"
         Arg="X0" />
<Description>
In the example above we see that <Code>X4</Code> has 
<C>IsPreXMod</C> and <C>IsXMod</C>. 
Precrossed modules will be considered in section 
<Ref Sect="sect-precrossed-modules" />. 
</Description>
</ManSection>

<ManSection>
   <Prop Name="IsPerm2DimensionalGroup"
         Arg="X0" />
   <Prop Name="IsPc2DimensionalGroup"
         Arg="X0" />
   <Prop Name="IsFp2DimensionalGroup"
         Arg="X0" />
<Description>
A structure which has <C>IsPerm2DimensionalGroup</C> is a (pre-)crossed module 
or a pre-cat1-group (see section <Ref Sect="sect-cat1" />) 
whose source and range are both permutation groups. 
The properties <C>IsPc2DimensionalGroup</C>, <C>IsFp2DimensionalGroup</C> 
are defined similarly. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> IsPerm2DimensionalGroup( X4 );
true
gap> IsPc2DimensionalGroup( Xn );  
true
gap> IsFp2DimensionalGroup( Xn );
false
]]>
</Example>

<ManSection>
   <Prop Name="IsNormalSubgroup2DimensionalGroup"
         Arg="X0" />
   <Prop Name="IsAutomorphismGroup2DimensionalGroup"
         Arg="X0" />
   <Prop Name="IsTrivialAction2DimensionalGroup"
         Arg="X0" />
   <Prop Name="IsCentralExtension2DimensionalGroup"
         Arg="X0" />
   <Prop Name="IsAbelianModule2DimensionalGroup"
         Arg="X0" />
<Description>
These are the properties corresponding to the various construction methods 
listed in section <Ref Sect="sect-constructions"/>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> IsNormalSubgroup2DimensionalGroup( X4 );
true
gap> IsAutomorphismGroup2DimensionalGroup( X5 );
true
gap> IsTrivialAction2DimensionalGroup( X45 );
true
gap> IsCentralExtension2DimensionalGroup( X23 );
true
]]>
</Example>

</Section>


<Section Label="sect-sub-xmods">
<Heading> Sub-crossed modules</Heading>

<ManSection>
   <Oper Name="SubXMod"
         Arg="X0 src rng" />
   <Attr Name="TrivialSubXMod"
         Arg="X0" />
<Description>
A sub-crossed module <M>\mathcal{Y}</M> of 
<M>\mathcal{X} = (\partial : S \to R)</M> 
has the form <M>(\delta : N \to M)</M>  where 
<List>
<Item>
<M>N,M</M> are subgroups of <M>S,R</M> respectively; 
</Item>
<Item>
<M>\delta</M> is the restriction of <M>\partial</M> to <M>N</M>, 
and <M>\delta(N) \subseteq M</M>; 
</Item>
<Item>
the action of <M>M</M> on <M>N</M> is the restriction of the action of 
<M>\mathcal{X}</M>, and <M>N</M> is closed under this action. 
<P/>
</Item>
</List>
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> d8 := Subgroup( s4, [ (1,2,3,4), (1,3) ] );; 
gap> k4 := Subgroup( d8, [ (1,2)(3,4), (1,3)(2,4) ] );; 
gap> SetName( d8, "d8" );  SetName( k4, "k4" ); 
gap> Y4 := SubXMod( X4, k4, d8 ); 
[k4->d8]
gap> TrivialSubXMod( X5 ); 
[Group( () )->Group( IdentityMapping( c5 ) )]
]]>
</Example>


<Index>IsNormal for crossed modules</Index>
<ManSection>
   <Meth Name="IsNormal"
         Arg="X0 S0" />
   <Attr Name="NormalSubXMods"
         Arg="X0" />
<Description>
A method for <C>IsNormal</C> for precrossed modules is provided. 
A sub-crossed module  <M>\mathcal{S} = (\delta : N \to M)</M>
is <E>normal</E> in <M>\mathcal{X} = (\partial : S \to R)</M>  if
<List>
<Item>
<M>N,M</M> are normal subgroups of <M>S,R</M> respectively,
</Item>
<Item>
<M>n^r \in N</M>  for all  <M>n \in N,~r \in R</M>,
</Item>
<Item>
<M>(s^{-1})^ms \in N</M>  for all  <M>m \in M,~s \in S</M>.
</Item>
</List>
These conditions ensure that  <M>M \ltimes N</M>  is normal in  
the semidirect product <M>R \ltimes S</M>. 
(Note that <M>\langle s,m \rangle = (s^{-1})^ms</M> 
is a displacement: see <Ref Func="Displacement" />.)
<P/>
See section <Ref Sect="sect-more-xmod-ops"/> for factor crossed modules 
<M>\mathcal{X}/\mathcal{N}</M> and their natural morphisms. 
<P/> 
The five normal sub-crossed modules of <C>X4</C> found in the following 
example are <C>[id,id], [k4,k4], [k4,a4], [a4,a4]</C> 
and <C>X4</C> itself. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> Z4 := SubXMod( X4, k4, a4 ); 
[k4->a4]
gap> [ IsNormal( X4, Y4 ), IsNormal( X4, Z4 ) ];  
[ false, true ]
gap> NX4 := NormalSubXMods( X4 );;
gap> List( NX4, X -> StructureDescription(X) );
[ [ "1", "1" ], [ "A4", "A4" ], [ "C2 x C2", "A4" ], [ "C2 x C2", "C2 x C2" ],
  [ "A4", "S4" ] ]
]]>
</Example>

</Section>


<Section Label="sect-precrossed-modules">
<Heading>Pre-crossed modules</Heading>

<Index>pre-crossed module</Index>
<ManSection>
   <Oper Name="PreXModByBoundaryAndAction"
         Arg="bdy act" />
   <Oper Name="SubPreXMod"
         Arg="X0 src rng" />
<Description>
If axiom  <M>{\bf XMod\ 2}</M> is <E>not</E> satisfied, 
the corresponding structure is known as a <E>pre-crossed module</E>.
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> b1 := (11,12,13,14,15,16,17,18);;  b2 := (12,18)(13,17)(14,16);;
gap> d16 := Group( b1, b2 );;
gap> sk4 := Subgroup( d16, [ b1^4, b2 ] );;
gap> SetName( d16, "d16" );  SetName( sk4, "sk4" );
gap> bdy16 := GroupHomomorphismByImages( d16, sk4, [b1,b2], [b1^4,b2] );;
gap> aut1 := GroupHomomorphismByImages( d16, d16, [b1,b2], [b1^5,b2] );;
gap> aut2 := GroupHomomorphismByImages( d16, d16, [b1,b2], [b1,b2^4*b2] );;
gap> aut16 := Group( [ aut1, aut2 ] );;
gap> act16 := GroupHomomorphismByImages( sk4, aut16, [b1^4,b2], [aut1,aut2] );;
gap> P16 := PreXModByBoundaryAndAction( bdy16, act16 );
[d16->sk4]
gap> IsXMod( P16 );
false
gap> S16 := SubPreXMod( P16, sk4, sk4 ); 
[sk4->sk4]
]]>
</Example>

<Index>Peiffer subgroup</Index>
<ManSection>
   <Attr Name="PeifferSubgroup"
         Arg="X0" />
   <Attr Name="XModByPeifferQuotient"
         Arg="prexmod" />
<Description>
The <E>Peiffer subgroup</E> <M>P</M> of a pre-crossed module 
<M>{\mathcal X}</M> is the subgroup of <M>{\rm ker}(\partial)</M> 
generated by  <E>Peiffer commutators</E>
<Display>
\lfloor s_1,s_2 \rfloor ~=~ 
(s_1^{-1})^{\partial s_2}~s_2^{-1}~s_1~s_2 ~=~ 
\langle \partial s_2, s_1 \rangle\ [s_1,s_2]~.
</Display>
Then  <M>\mathcal{P} = (0 : P \to \{1_R\})</M>
is a normal sub-pre-crossed module of  <M>\mathcal{X}</M>
and  <M>\mathcal{X}/\mathcal{P} = (\partial : S/P \to R)</M>
is a crossed module.
<P/>
In the following example the Peiffer subgroup of <C>P16</C> 
is cyclic of size <M>4</M>, while the Peiffer subgroup of the 
sub-precrossed module <C>S16</C> has order <M>2</M>. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> P := PeifferSubgroup( P16 );
Group( [ (11,15)(12,16)(13,17)(14,18), (11,17,15,13)(12,18,16,14) ] )
gap> PeifferSubgroup( S16 );
Group([ (11,15)(12,16)(13,17)(14,18) ])
gap> X16 := XModByPeifferQuotient( P16 );
Peiffer([d16->sk4])
gap> Display( X16 );
Crossed module Peiffer([d16->sk4]) :-
: Source group has generators:
  [ f1, f2 ]
: Range group has generators:
  [ (11,15)(12,16)(13,17)(14,18), (12,18)(13,17)(14,16) ]
: Boundary homomorphism maps source generators to:
  [ (12,18)(13,17)(14,16), (11,15)(12,16)(13,17)(14,18) ]
  The automorphism group is trivial
gap> StructureDescription(X16);
[ "C2 x C2", "C2 x C2" ]
]]>
</Example>

</Section>


<Section Label="sect-cat1">
<Heading>Cat1-groups and pre-cat1-groups</Heading>
<Index>cat1-group</Index>

In <Cite Key="L1" />, Loday reformulated the notion of a 
crossed module as a cat1-group, 
namely a group <M>G</M> with a pair of endomorphisms <M>t,h : G \to G</M>
having  a common image <M>R</M> and satisfying certain axioms.
We find it computationally convenient to define a cat1-group 
<M>\mathcal{C} = (e;t,h : G \to R )</M>  as having source group  <M>G</M>,
range group <M>R</M>,  and three homomorphisms:  two surjections  
<M>t,h : G \to R</M>  and an embedding  <M>e : R \to G</M>  satisfying:
<Display>
{\bf Cat\ 1}  :  ~t \circ e ~=~ h \circ e = {\rm id}_R,
\qquad
{\bf Cat\ 2}  :  ~[\ker t, \ker h] ~=~ \{ 1_G \}.
</Display>
It follows that  
<M>\;t \circ e \circ h = h,~ h \circ e \circ t = t,~ 
     t \circ e \circ t = t~</M> 
and <M>~h \circ e \circ h = h</M>. 
(See section <Ref Sect="sect-properties-cat1"/> for the case when 
<M>t,h</M> are endomorphisms.) 

<ManSection Label="mansect-cat1">
   <Func Name="Cat1Group"
         Arg="args" />
   <Func Name="PreCat1Group"
         Arg="args" />
   <Oper Name="PreCat1GroupByTailHeadEmbedding"
         Arg="t h e" />
   <Oper Name="PreCat1GroupByEndomorphisms"
         Arg="t h" />
<Description>
The global functions <C>Cat1Group</C> and <C>PreCat1Group</C> 
can be called in various ways. 
<List>
<Item>
as <C>Cat1Group(t,h,e);</C> when <M>t,h,e</M> are three homomorphisms, 
which is equivalent to <C>PreCat1GroupByTailHeadEmbedding(t,h,e);</C> 
</Item>
<Item>
as <C>Cat1Group(t,h);</C> when <M>t,h</M> are two endomorphisms, 
which is equivalent to <C>PreCat1GroupByEndomorphisms(t,h);</C> 
</Item>
<Item>
as <C>Cat1Group(t);</C> when <M>t=h</M> is an endomorphism, 
which is equivalent to <C>PreCat1GroupByEndomorphisms(t,t);</C> 
</Item>
<Item>
as <C>Cat1Group(t,e);</C> when <M>t=h</M> and <M>e</M> are homomorphisms, 
which is equivalent to <C>PreCat1GroupByTailHeadEmbedding(t,t,e);</C> 
</Item>
<Item>
as <C>Cat1Group(i,j,k);</C> when <M>i,j,k</M> are integers, 
which is equivalent to <C>Cat1Select(i,j,k);</C> 
as described in section <Ref Sect="sect-cat1select"/>. 
</Item>
</List>
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> g18gens := [ (1,2,3), (4,5,6), (2,3)(5,6) ];;     
gap> s3agens := [ (7,8,9), (8,9) ];;                
gap> g18 := Group( g18gens );;  SetName( g18, "g18" ); 
gap> s3a := Group( s3agens );;  SetName( s3a, "s3a" );
gap> t1 := GroupHomomorphismByImages(g18,s3a,g18gens,[(7,8,9),(),(8,9)]);     
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -> [ (7,8,9), (), (8,9) ]
gap> h1 := GroupHomomorphismByImages(g18,s3a,g18gens,[(7,8,9),(7,8,9),(8,9)]);
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -> [ (7,8,9), (7,8,9), (8,9) ]
gap> e1 := GroupHomomorphismByImages(s3a,g18,s3agens,[(1,2,3),(2,3)(5,6)]);   
[ (7,8,9), (8,9) ] -> [ (1,2,3), (2,3)(5,6) ]
gap> C18 := Cat1Group( t1, h1, e1 );
[g18=>s3a]
]]>
</Example>

</Section>


<Section Label="sect-cat1-attr">
<Heading>Attributes of cat1-groups</Heading>

These are the attributes of a cat1-group <M>\mathcal{C}</M> 
in this implementation.
<P/>

<ManSection>
   <Attr Name="Source"
         Arg="C" Label="for cat1-groups" />
   <Attr Name="Range"
         Arg="C" Label="for cat1-groups" />
   <Attr Name="TailMap"
         Arg="C" />
   <Attr Name="HeadMap"
         Arg="C" />
   <Attr Name="RangeEmbedding"
         Arg="C" />
   <Attr Name="KernelEmbedding"
         Arg="C" />
   <Attr Name="Boundary"
         Arg="C" Label="for cat1-groups" />
   <Attr Name="Name"
         Arg="C" Label="for cat1-groups" />
   <Attr Name="Size"
         Arg="C" Label="for cat1-groups" />
<Description> 
The <C>TailMap</C> <M>t</M> and the <C>HeadMap</C> <M>h</M>  
are often referred to as the <E>source</E> and <E>target</E>.
We choose to call them the
<E>tail</E> and <E>head</E> of <M>\mathcal{C}</M>, 
because <E>source</E> is the &GAP; term for the domain of a function.
The <C>RangeEmbedding</C> <M>e</M> is the embedding of <C>R</C> in <C>G</C>;
the <C>KernelEmbedding</C> is the inclusion of 
the kernel of <C>t</C> in <C>G</C>; 
and the <C>Boundary</C> is the restriction of <C>h</C> 
to the kernel of <C>t</C>. 
It is frequently the case that <M>t=h</M>, 
but not in the example <C>C18</C> above. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Source( C18 );
g18
gap> Range( C18 );
s3a
gap> TailMap( C18 );
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -> [ (7,8,9), (), (8,9) ]
gap> HeadMap( C18 );
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -> [ (7,8,9), (7,8,9), (8,9) ]
gap> RangeEmbedding( C18 );
[ (7,8,9), (8,9) ] -> [ (1,2,3), (2,3)(5,6) ]
gap> Kernel( C18 );
Group([ (4,5,6) ])
gap> KernelEmbedding( C18 );
[ (4,5,6) ] -> [ (4,5,6) ]
gap> Name( C18 );
"[g18=>s3a]"
gap> Size( C18 );
[ 18, 6 ]
gap> StructureDescription( C18 );
[ "(C3 x C3) : C2", "S3" ]
]]>
</Example>

</Section>


<Section Label="sect-properties-cat1">
<Heading>Properties of cat1-groups and pre-cat1-groups</Heading>

Many of the properties listed in section <Ref Sect="sect-properties-xmod"/> 
apply to pre-cat1-groups and to cat1-groups since these are also 2d-groups. 
There are also more specific properties. 

<ManSection>
   <Prop Name="IsCat1Group"
         Arg="C0" />
   <Prop Name="IsPreXCat1Group"
         Arg="C0" />
   <Prop Name="IsIdentityCat1Group"
         Arg="C0" />
<Description>
<C>IsIdentityCat1Group(C0)</C> is true when the head and tail maps of <C>C0</C> 
are identity mappings. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> G2 := SmallGroup( 288, 956 );  SetName( G2, "G2" );
<pc group of size 288 with 7 generators>
gap> d12 := DihedralGroup( 12 );  SetName( d12, "d12" );
<pc group of size 12 with 3 generators>
gap> a1 := d12.1;;  a2 := d12.2;;  a3 := d12.3;;  a0 := One( d12 );;
gap> gensG2 := GeneratorsOfGroup( G2 );;
gap> t2 := GroupHomomorphismByImages( G2, d12, gensG2,
>           [ a0, a1*a3, a2*a3, a0, a0, a3, a0 ] );;
gap> h2 := GroupHomomorphismByImages( G2, d12, gensG2,
>           [ a1*a2*a3, a0, a0, a2*a3, a0, a0, a3^2 ] );;                   
gap> e2 := GroupHomomorphismByImages( d12, G2, [a1,a2,a3],
>        [ G2.1*G2.2*G2.4*G2.6^2, G2.3*G2.4*G2.6^2*G2.7, G2.6*G2.7^2 ] );
[ f1, f2, f3 ] -> [ f1*f2*f4*f6^2, f3*f4*f6^2*f7, f6*f7^2 ]
gap> C2 := PreCat1GroupByTailHeadEmbedding( t2, h2, e2 );
[G2=>d12]
gap> IsCat1Group( C2 );
true
gap> KnownPropertiesOfObject( C2 );
[ "CanEasilyCompareElements", "CanEasilySortElements", "IsDuplicateFree", 
  "IsGeneratorsOfSemigroup", "IsPreCat1Domain", "IsPc2DimensionalGroup", 
  "IsPreCat1Group", "IsCat1Group", "IsEndomorphismPreCat1Group" ]
]]>
</Example>

<ManSection>
   <Attr Name="EndomorphismPreCat1Group" 
         Arg="C0" /> 
   <Prop Name="IsEndomorphismPreCat1Group"
         Arg="C0" />
<Description>
<C>IsEndomorphismPreCat1Group(C0)</C> is true when the range of <C>C0</C> 
is a subgroup of the source. 
When this is not the case, replacing <M>t,h,e</M> by <M>t*e,h*e</M> 
and the inclusion mapping of the image of <M>e</M> gives an isomorphic 
cat1-group for which <C>IsEndomorphismPreCat1Group</C> is true. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> IsEndomorphismPreCat1Group( C18 );
false
gap> X18 := EndomorphismPreCat1Group( C18 );
[g18=>Group( [ (1,2,3), (), (2,3)(5,6) ] )]
]]>
</Example>

</Section>


<Section Label="sect-cat1-constructions">
<Heading>More cat1-group constructions</Heading>

This section describes some more constructors for cat1-groups. 

<ManSection>
   <Oper Name="SubCat1Group" 
         Arg="C, H, Q" />
   <Oper Name="SubPreCat1Group" 
         Arg="C, H, Q" />
   <Oper Name="Sub2DimensionalGroup" 
         Arg="C, H, Q" />
<Description>
If <M>\mathcal{C} = (e;t,h : G \to R)</M>, 
if <M>H,Q</M> are subgroups of <M>G,R</M> respectively, 
and if <M>t',h',e'</M> are well-defined restrictions of <M>t,h,e</M> 
to <M>G,R</M> then <M>\mathcal{C}' = (e';t',h' : H \to Q)</M> 
is a sub-cat1-group of <M>\mathcal{C}</M>. 
The operation <C>SubPreCat1Group</C> applies similarly to sub-cat1-groups. 
The operation <C>Sub2DimensionalGroup</C> calls one of the previous operations 
or one of <C>SubXMod, SubPreXMod</C> as appropriate. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> SubCat1Group( C18, Subgroup( g18, [ (1,2,3), (4,5,6) ] ), 
>        Subgroup( s3a, [ (7,8,9) ] ) ); 
[Group( [ (1,2,3), (4,5,6) ] )=>Group( [ (7,8,9) ] )]
]]>
</Example>

<ManSection>
   <Oper Name="DiagonalCat1Group" 
         Arg="gens" />
<Description>
Given generators for a group <M>R</M>, form <M>G = R \times R</M>. 
Define <M>t,h</M> to be the projections <M>G \to R</M> 
of the first and second factors respectively. 
The embedding <M>e</M> is the diagonal map <M>r \mapsto (r,r)</M>. 
These maps define a cat1-group. 
The operation <C>DiagonalCat1Group(gens)</C> returns the 
endomorphism cat1-group of this construction. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> C64 := DiagonalCat1Group( [(1,2,3,4), (3,4)] );
[Group( [ (1,2,3,4), (3,4), (5,6,7,8), (7,8) ] )=>Group( 
[ (1,2,3,4)(5,6,7,8), (3,4)(7,8) ] )]
gap> Display( C64 );

Cat1-group :- 
: Source group has generators:
  [ (1,2,3,4), (3,4), (5,6,7,8), (7,8) ]
: Range group has generators:
  [ (1,2,3,4)(5,6,7,8), (3,4)(7,8) ]
: tail homomorphism maps source generators to:
  [ (1,2,3,4)(5,6,7,8), (3,4)(7,8), (), () ]
: head homomorphism maps source generators to:
  [ (), (), (1,2,3,4)(5,6,7,8), (3,4)(7,8) ]
: range embedding maps range generators to:
  [ (1,2,3,4)(5,6,7,8), (3,4)(7,8) ]
: kernel has generators:
  [ (5,6,7,8), (7,8) ]
: boundary homomorphism maps generators of kernel to:
  [ (1,2,3,4)(5,6,7,8), (3,4)(7,8) ]
: kernel embedding maps generators of kernel to:
  [ (5,6,7,8), (7,8) ]

]]>
</Example>

<ManSection>
   <Oper Name="PreCat1GroupByNormalSubgroup"
         Arg="G N" />
<Description>
To follow. 
</Description>
</ManSection>


<ManSection>
   <Oper Name="Cat1GroupByPeifferQuotient"
         Arg="P" />
<Description>
To follow.
</Description>
</ManSection>


<ManSection>
   <Attr Name="ReverseCat1Group"
         Arg="C0" />
<Description>
To follow.
</Description>
</ManSection>


</Section>


<Section Label="sect-xmod-cat1-conversion">
<Heading>Equivalence of crossed modules and cat1-groups</Heading>

The category of crossed modules is equivalent to the category of cat1-groups,
and the functors between these two categories are implemented in the 
following operations.

<ManSection>
   <Attr Name="Cat1GroupOfXMod"
         Arg="X0" />
   <Attr Name="XModOfCat1Group"
         Arg="C0" />
   <Attr Name="PreCat1GroupOfPreXMod"
         Arg="P0" />
   <Attr Name="PreXModOfPreCat1Group"
         Arg="P0" />
<Description>

Starting with the crossed module 
<M>\mathcal{X} = (\partial : S \to R)</M> the group <M>G</M> is defined 
as the semidirect product <M>G = R \ltimes S</M>
using the action from  <M>\mathcal{X}</M>,
with multiplication rule
<Display>
(r_1,s_1)(r_2,s_2) ~=~ (r_1r_2,{s_1}^{r_2}s_2).
</Display>
The structural morphisms are given by
<Display>
t(r,s) = r, \quad h(r,s) = r (\partial s), \quad er = (r,1).
</Display>
On the other hand, starting with a cat1-group 
<M> \mathcal{C} = (e;t,h : G \to R)</M>,  we define 
<M> S = \ker t</M>, the range <M>R</M> is unchanged, and 
<M> \partial = h\!\mid_S </M>.
The action of  <M>R</M>  on  <M>S</M>  is conjugation in  <M>G</M>  via the embedding
of  <M>R</M>  in  <M>G</M>.
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> X2 := XModOfCat1Group( C2 );;
gap> Display( X2 );

Crossed module X([G2=>d12]) :- 
: Source group has generators:
  [ f1, f4, f5, f7 ]
: Range group d12 has generators:
  [ f1, f2, f3 ]
: Boundary homomorphism maps source generators to:
  [ f1*f2*f3, f2*f3, <identity> of ..., f3^2 ]
: Action homomorphism maps range generators to automorphisms:
  f1 --> { source gens --> [ f1*f5, f4*f5, f5, f7^2 ] }
  f2 --> { source gens --> [ f1*f5*f7^2, f4, f5, f7 ] }
  f3 --> { source gens --> [ f1*f7, f4, f5, f7 ] }
  These 3 automorphisms generate the group of automorphisms.
: associated cat1-group is [G2=>d12]

gap> StructureDescription(X2);
[ "D24", "D12" ]

]]>
</Example>
</Section>


<Section Label="sect-cat1select">
<Heading>Selection of a small cat1-group</Heading>
<Index>selection of a small cat1-group</Index>

The <C>Cat1Group</C> function may also be used to select a cat1-group 
from a data file.
All cat1-structures on groups of size up to <M>70</M> 
(ordered according to the &GAP; 4 numbering of small groups) 
are stored in a list in file <F>cat1data.g</F>.
Global variables <C>CAT1&uscore;LIST&uscore;MAX&uscore;SIZE := 70</C> and
<C>CAT1&uscore;LIST&uscore;CLASS&uscore;SIZES</C> are also stored. 
The data is read into the list <C>CAT1&uscore;LIST</C> 
only when this function is called. 

<ManSection>
   <Oper Name="Cat1Select"
         Arg="size gpnum num" />
<Description>
The function <C>Cat1Select</C> may be used in three ways. 
<C>Cat1Select( size )</C> returns the names of the groups with this size, 
while <C>Cat1Select( size, gpnum )</C> prints a list of cat1-structures 
for this chosen group. 
<C>Cat1Select( size, gpnum, num )</C> returns the chosen cat1-group.
<P/>
The example below is the first case in which <M>t \neq h</M>
and the associated conjugation crossed module
is given by the normal subgroup <C>c3</C> of <C>s3</C>.
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> ## check the number of groups of size 18
gap> L18 := Cat1Select( 18 ); 
Usage:  Cat1Select( size, gpnum, num );
[ "D18", "C18", "C3 x S3", "(C3 x C3) : C2", "C6 x C3" ]
gap> ## check the number of cat1-structures on the fourth of these
gap> Cat1Select( 18, 4 );
Usage:  Cat1Select( size, gpnum, num );
There are 4 cat1-structures for the group (C3 x C3) : C2.
Using small generating set [ f1, f2, f2*f3 ] for source of homs.
[ [range gens], [tail genimages], [head genimages] ] :-
(1)  [ [ f1 ], [ f1, <identity> of ..., <identity> of ... ], 
  [ f1, <identity> of ..., <identity> of ... ] ]
(2)  [ [ f1, f3 ], [ f1, <identity> of ..., f3 ], 
  [ f1, <identity> of ..., f3 ] ]
(3)  [ [ f1, f3 ], [ f1, <identity> of ..., f3 ], 
  [ f1, f3^2, <identity> of ... ] ]
(4)  [ [ f1, f2, f2*f3 ],  tail = head = identity mapping ]
4
gap> ## select the third of these cat1-structures 
gap> C18a := Cat1Group( 18, 4, 3 );
[(C3 x C3) : C2=>Group( [ f1, <identity> of ..., f3 ] )]
gap> ## convert from a pc-cat1-group to a permutation cat1-group
gap> iso18a := IsomorphismPermObject( C18a );;
gap> PC18a := Image( iso18a );;
gap> Display( PC18a );
Cat1-group :- 
: Source group has generators:
  [ (2,3)(5,6), (4,5,6), (1,2,3) ]
: Range group has generators:
  [ (2,3), (), (1,2,3) ]
: tail homomorphism maps source generators to:
  [ (2,3), (), (1,2,3) ]
: head homomorphism maps source generators to:
  [ (2,3), (1,3,2), (1,2,3) ]
: range embedding maps range generators to:
  [ (2,3)(5,6), (), (1,2,3) ]
: kernel has generators:
  [ (4,5,6) ]
: boundary homomorphism maps generators of kernel to:
  [ (1,3,2) ]
: kernel embedding maps generators of kernel to:
  [ (4,5,6) ]
gap> convert the result to the associated permutation crossed module 
gap> X18a := XModOfCat1Group( PC18a );; 
gap> Display( X18a ); 
Crossed module:- 
: Source group has generators:
  [ (4,5,6) ]
: Range group has generators:
  [ (2,3), (), (1,2,3) ]
: Boundary homomorphism maps source generators to:
  [ (1,3,2) ]
: Action homomorphism maps range generators to automorphisms:
  (2,3) --> { source gens --> [ (4,6,5) ] }
  () --> { source gens --> [ (4,5,6) ] }
  (1,2,3) --> { source gens --> [ (4,5,6) ] }
  These 3 automorphisms generate the group of automorphisms.
: associated cat1-group is [..=>..]
]]>
</Example>

<ManSection>
   <Oper Name="AllCat1DataGroupsBasic" 
         Arg="gp" /> 
<Description>
For a group <M>G</M> of size greater than <M>70</M> which is reasonably 
straightforward this function may be used to construct a list of all 
cat1-group structures on <M>G</M>. 
The operation also attempts to write output to a file in the folder 
<F>xmod/lib</F>. 
(Other operations in the file <F>cat1data.gi</F> have been used to deal 
with the more complicated groups of size up to <M>70</M>, 
but these are not described here.) 
<P/> 
Van Luyen Le has a more efficient algorithm, extending the data 
up to groups of size 171, which is expected to appear in a future 
release of <Package>HAP</Package>. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> gp := SmallGroup( 102, 2 ); 
<pc group of size 102 with 3 generators>
gap> StructureDescription( gp ); 
"C3 x D34"
gap> all := AllCat1DataGroupsBasic( gp );
#I Edit last line of .../xmod/lib/nn.kk.out to end with ] ] ] ] ]
[ [Group( [ f1, f2, f3 ] )=>Group( [ f1, <identity> of ..., <identity> of ... 
     ] )], [Group( [ f1, f2, f3 ] )=>Group( [ f1, f2, <identity> of ... ] )], 
  [Group( [ f1, f2, f3 ] )=>Group( [ f1, <identity> of ..., f3 ] )], 
  [Group( [ f1, f2, f3 ] )=>Group( [ f1, f2, f3 ] )] ]
]]>
</Example>

</Section>

</Chapter>
