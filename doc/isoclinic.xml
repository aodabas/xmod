<!-- ------------------------------------------------------------------- -->
<!--                                                                     -->
<!--  isclinic.xml          XMod documentation             Alper Odabas  -->
<!--                                                       & Enver Uslu  -->
<!--  version 2.43, 06/10/2015                                           --> 
<!--                                                                     --> 
<!--  Copyright (C) 2001-2015, Chris Wensley et al                       --> 
<!--                                                                     -->
<!-- ------------------------------------------------------------------- -->

<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="chap-isclnc">
<Heading>Isoclinism of Crossed Modules</Heading>

This chapter describes some functions written by Alper Odaba&#x15f; and  
Enver Uslu, and reported in <Cite Key="OUI1" />. 
Firstly, they consist of some additional basic functions for crossed modules, 
constructing quotients, centres, centralizers and normalizers.
Secondly, there are some functions dealing specifically with isoclinism. 


<Section Label="iso-ops">
<Heading>More operations for crossed modules</Heading>

<ManSection>
   <Oper Name="FactorXMod"
         Arg="X1 X2" />
   <Oper Name="NaturalMorphismByNormalSubXMod"
         Arg="X1 X2" />
<Description>
When <M>\mathcal{X}_2 = (\partial_2 : S_2 \to R_2)</M> 
is a normal subcrossed module of 
<M>\mathcal{X}_1 = (\partial_1 : S_1 \to R_1)</M>, 
then the quotient crossed module is 
<M>(\partial : S_2/S_1 \to R_2/R_1)</M>
with the induced boundary and action maps. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> X24 := XModByAutomorphismGroup( D24 ); 
[D24->PAut(D24)]
gap> Size(X24);
[ 24, 48 ]
gap> nsx := NormalSubXMods( X24 );; 
gap> Length( nsx );  Size( nsx[30] );
40
[ 4, 8 ]
gap> Q := FactorXMod( X24, nsx[30] ); 
[Group( [ f1, f2, f2^2, f2 ] )->Group( 
[ f1, f2, <identity> of ..., <identity> of ..., <identity> of ... ] )]
gap> Size( Q );
[ 6, 6 ]
gap> nat := NaturalMorphismByNormalSubXMod( X24, nsx[30] ); 
[[D24->PAut(D24)] => [..]]
]]>
</Example>

<ManSection>
   <Oper Name="IntersectionSubXMod"
         Arg="X1 X2" />
<Description>
When <C>X1,X2</C> are subcrossed modules of <C>X0</C>, and when 
<C>Y12 := IntersectionSubXMod(X1,X2)</C>, 
then the source and range of <C>Y12</C> are the intersections of 
the sources and ranges of <C>X1</C> and <C>X2</C>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> N3 := norm[3];;  N4 := norm[4];;             
gap> bdy := Boundary( X24 ); 
[ f1, f2, f3, f4 ] -> [ f1*f3, f2*f5, f2^2, f2 ]
gap> R3 := Image( bdy, N3 );; 
gap> X3 := SubXMod( X24, N3, R3 );
[Group( [ f1*f2*f3*f4^2, f3, f4 ] )->Group( [ f1*f2^2*f3*f5, f2^2, f2 ] )]
gap> R4 := Image( bdy, N4 );; 
gap> X4 := SubXMod( X24, N4, R4 );
[Group( [ f1, f3, f4 ] )->Group( [ f1*f3, f2^2, f2 ] )]
gap> X6 := IntersectionSubXMod( X24, X3, X4 );
[Group( [ f3, f4, f3*f4, f4^2, f3*f4^2 ] )->Group( [ f2, f2^2 ] )]
gap> Size( X6 );
[ 6, 3 ]
]]>
</Example>

<ManSection>
   <Attr Name="DisplacementSubgroup"
         Arg="X0" />
   <Oper Name="Displacement"
         Arg="alpha s r" />
<Description> 
Commutators may be written <M>[q,r] = q^{-1}q^r = (r^{-1})^qr</M>, 
and satisfy identities 
<Display> 
[q,r]^p = [q^p,r^p], \qquad 
[pq,r] = [p,r]^q[q,r], \qquad 
[q,pr] = [q,r][q,p]^r, \qquad 
[q,r]^{-1} = [r,q]. 
</Display> 
In a similar way, when a group <M>R</M> acts on a group <M>S</M>, 
the <E>displacement</E> of <M>s \in S</M> and <M>r \in R</M> 
is defined to be <M>\langle s,r \rangle := s^{-1}s^r \in S</M>. 
When <M>\mathcal{X} = (\partial : S \to R)</M> is a pre-crossed module, 
the first axiom requires <M>\partial\langle s,r \rangle = [\partial s,r]</M>. 
For a given action <M>\alpha</M> the <C>Displacement</C> function 
may be used to calculate <M>\langle s,r \rangle</M>. 
Displacements satisfy the following identities, 
where <M>s,t \in S,~ q,r \in R</M>:  
<Display>
\langle s,r \rangle^q = \langle s^q,r^q \rangle, \qquad 
\langle st,r \rangle = \langle s,r \rangle^t \langle t,r \rangle, \qquad 
\langle s,qr \rangle = \langle s,r \rangle \langle s,q \rangle^r, \qquad 
\langle s,r \rangle^{-1} = \langle s^r,r^{-1} \rangle. 
</Display> 
The <C>DisplacementSubgroup</C> of <M>\mathcal{X}</M> is the subgroup <M>Disp(\mathcal{X})</M> of <M>S</M> generated by these displacements. 
The identities imply  
<M>\langle s,r \rangle^t = \langle st,r \rangle \langle t^r,r^{-1} \rangle</M>, 
so <M>Disp(\mathcal{X})</M> is normal in <M>S</M>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> D24 := DihedralGroup(24);
<pc group of size 24 with 4 generators>
gap> SetName( D24, "D24" );
gap> norm := NormalSubgroups( D24 );;
gap> List( norm, n->Size(n) );
[ 24, 12, 12, 12, 6, 4, 2, 3, 1 ]
gap> N5 := norm[5];;
gap> X5 := XModByNormalSubgroup( D24, N5 );
[Group( [ f3, f4 ] )->D24]
gap> SetName( X5, "X5" );
gap> Size( X5 );
[ 6, 24 ]
gap> d := Displacement( XModAction(X5), N5.1, D24.1 );
f4^2
gap> Image( Boundary(X5), d ) = Comm( N5.1, D24.1 );  
true
gap> DisplacementSubgroup( X5 );
Group([ f4^2, f4 ])
]]>
</Example>

<ManSection>
   <Oper Name="CommutatorSubXMod"
         Arg="X X1 X2" />
   <Oper Name="CrossActionSubgroup"
         Arg="X X1 X2" />
<Description>
When <M>\mathcal{X}_1 = (N \to Q), \mathcal{X}_2 = (M \to P)</M> 
are two normal subcrossed modules of <M>\mathcal{X} = (\partial : S \to R)</M>, 
the displacements <M>\langle n,p \rangle</M> and <M>\langle m,q \rangle</M> 
all map by <M>\partial</M> into <M>[Q,P]</M>. 
These displacements form a normal subgroup of <M>S</M>, 
called the <C>CrossActionSubgroup</C>. 
The <C>CommutatorSubXMod</C> <M>[\mathcal{X}_1,\mathcal{X}_2]</M> 
has this subgroup as source and <M>[P,Q]</M> as range, 
and is normal in <M>\mathcal{X}</M>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Y6 := CommutatorSubXMod( X24, X3, X4 );
[Group( [ f3, f4^2, f4 ] )->Group( [ f2 ] )]
gap> Size(Y6);
[ 6, 3 ]
gap> X6 = Y6;
false
]]>
</Example>

<ManSection>
   <Oper Name="FixedPointSubgroupXMod"
         Arg="X0 T Q" />
   <Oper Name="StabilizerSubgroupXMod"
         Arg="X0 T Q" />
   <Attr Name="DerivedSubXMod"
         Arg="X0" />
<Description>
The <C>FixedPointSubgroupXMod(X,T,Q)</C> 
for <M>\mathcal{X}=(\partial : S \to R)</M> is the subgroup 
<M>Fix(\mathcal{X},T,Q)</M> 
of elements <M>t \in T \leqslant S</M> individually fixed 
under the action of <M>Q \leqslant R</M>. 
<P/>
The <C>StabilizerSubgroupXMod(X,T,Q)</C> for <M>\mathcal{X}</M> 
is the subgroup <M>Stab(\mathcal{X},T,Q)</M> of <M>Q \leqslant R</M> 
whose elements act trivially on the whole of <M>T \leqslant S</M>. 
<P/>
The <C>DerivedSubXMod</C> of <M>\mathcal{X}</M> is the normal subcrossed module 
<M>[\mathcal{X},\mathcal{X}] = (\partial' : Disp(\mathcal{X}) \to [R,R])</M> 
where <M>\partial'</M> is the restriction of <M>\partial</M>. 
<P/> 
These constructions are described on pages 19 and 66 of Norrie's thesis 
<Cite Key="N2" />. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> fix := FixedPointSubgroupXMod( X5, N5, D24 );
Group([ f3*f4 ])
gap> stab := StabilizerSubgroupXMod( X5, N5, D24 );
<pc group of size 12 with 1 generators>
gap> DX5 := DerivedSubXMod( X5 );  
[Group( [ f4^2, f4 ] )->Group( [ f3, f4 ] )]
]]>
</Example>

<ManSection>
   <Attr Name="CentreXMod"
         Arg="X0" />
   <Oper Name="Centralizer"
         Arg="X Y" />
   <Oper Name="Normalizer"
         Arg="X Y" />
<Description>
The <E>centre</E> of <M>\mathcal{X} = (\partial : S \to R)</M> 
has as source the fixed point subgroup <M>Fix(\mathcal{X},S,R)</M>. 
The range is the intersection of the centre <M>Z(R)</M>
with the stabilizer subgroup. 
<P/> 
When <M>\mathcal{Y} = (T \to Q)</M> is a subcrossed module of 
<M>\mathcal{X} = (\partial : S \to R)</M>, the <E>centralizer</E> 
<M>C_{\mathcal{X}}(\mathcal{Y})</M> of <M>\mathcal{Y}</M> 
has as source the fixed point subgroup <M>Fix(\mathcal{X},S,Q)</M>. 
The range is the intersection of the centralizer <M>C_R(Q)</M> 
with <M>Stab(\mathcal{X},T,R)</M>. 
<P/>
The <E>normalizer</E> <M>N_{\mathcal{X}}(\mathcal{Y})</M> 
of <M>\mathcal{Y}</M> has as source the subgroup of <M>S</M> 
consisting of the displacements <M>\langle s,q \rangle</M> 
which lie in <M>S</M>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> ZX5 := CentreXMod( X5 );      
[Group( [ f3*f4 ] )->Group( [ f3*f4 ] )]
gap> IdGroup( ZX5 );
[ [ 2, 1 ], [ 2, 1 ] ]
gap> CDX5 := Centralizer( X5, DX5 );
[Group( [ f3*f4 ] )->Group( [ f3 ] )]
gap> IdGroup( CDX5 );    
[ [ 2, 1 ], [ 6, 2 ] ]
gap> NDX5 := Normalizer( X5, DX5 ); 
[Group( <identity> of ... )->Group( [ f2 ] )]
gap> IdGroup( NDX5 );
[ [ 1, 1 ], [ 12, 2 ] ]
]]>
</Example>

<ManSection>
   <Prop Name="IsAbelian2dGroup"
         Arg="X0" />
   <Prop Name="IsAspherical2dGroup"
         Arg="X0" />
   <Prop Name="IsSimplyConnected2dGroup"
         Arg="X0" />
   <Prop Name="IsFaithful2dGroup"
         Arg="X0" />
<Description>
Need some description here.
</Description>
</ManSection>
<Example>
<![CDATA[
gap> [ IsAbelian2dGroup(X5), IsAbelian2dGroup(X24) ];
[ false, false ]
gap> [ IsAspherical2dGroup(X5), IsAspherical2dGroup(X24) ];
[ true, false ]
gap> [ IsSimplyConnected2dGroup(X5), IsSimplyConnected2dGroup(X24) ];
[ true, true ]
gap> [ IsFaithful2dGroup(X5), IsFaithful2dGroup(X24) ];              
[ false, true ]
]]>
</Example>

<ManSection>
   <Prop Name="IsNilpotent2dGroup"
         Arg="X0" />
   <Attr Name="NilpotencyClass2dGroup"
         Arg="X0" />
   <Attr Name="LowerCentralSeriesOfXMod"
         Arg="X0" />
<Description>
Need some description here. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> LX1 := LowerCentralSeriesOfXMod( X1 );
[ [c5->PAut(c5)], [Group( [ (5,6,7,8,9) ] )->Group( () )] ]
gap> List( LX1, x -> Size(x) );            
[ [ 5, 4 ], [ 5, 1 ] ]
gap> IsNilpotent2dGroup( X1 );             
false
gap> NilpotencyClass2dGroup( X1 );         
0
]]>
</Example>

<ManSection>
   <Oper Name="AllXMods"
         Arg="min max" />
   <Oper Name="AllPreXMods"
         Arg="min max" />
<Description>
These functions compute all crossed modules 
(respectively all precrossed modules) such that both the source 
and range groups have size in the interval <C>[min..max]</C>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> px24 := AllPreXMods( 2, 4 );;
gap> Length( px24 );              
122
gap> x24 := AllXMods( 2, 4 );;   
gap> Length( x24 );           
94
]]>
</Example>

<ManSection>
   <Oper Name="IsomorphismXMods"
         Arg="X1 X2" />
<Description>
This function computes an isomorphism 
<M>\mu : \mathcal{X}_1 \to \mathcal{X}_2</M>, 
provided one exists, or else returns <C>fail</C>. 
The calculation in the example below shows that the <M>94</M> crossed modules 
in <C>x24</C> (see the previous subsection) fall into <M>60</M> isomorphism classes. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> IsomorphismXMods( x24[7], x24[8] );
[[Group( [ f1 ] )->Group( [ f1, f2 ] )] => [Group( [ f1 ] )->Group( 
[ f1, f2 ] )]]
gap> L := ListWithIdenticalEntries( 94, 1 );;
gap> for i in [1..93] do 
>      if ( L[i] = 1 ) then 
>        X1 := x24[i]; 
>        for j in [i+1..94] do 
>          if ( L[j] = 1 ) then 
>            X2 := x24[j];            
>            mor := IsomorphismXMods( X1, X2 ); 
>            if ( mor <> fail ) then L[j]:=0; fi; 
>          fi;
>        od;
>      fi;
>    od;
gap> L;
[ 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 
  1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 
  1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1 ]
gap> Sum( L );
60
]]>
</Example>




</Section>




<Section><Heading>Isoclinism of Groups</Heading>

<ManSection>
   <Attr Name="CentralQuotient"
         Arg="G" /> 
   <Attr Name="CentralQuotientHomomorphism"
         Arg="G" />
   <Oper Name="AreIsoclinicGroups"
         Arg="G H" />
<Description>
Let <M>G,H</M> be groups with central quotients 
<M>Q(G)=G/Z(G)</M> and <M>Q(H)=H/Z(H)</M> 
and derived subgroups <M>[G,G]</M> and <M>[H,H]</M> respectively. 
Let <M>c_G : Q(G) \times Q(G) \to [G,G]</M> 
and <M>c_H : Q(H) \times Q(H) \to [H,H]</M> be the two commutator maps.  
An <E>isoclinism</E> <M>G \sim H</M> is a pair of isomorphisms 
<M>(\eta,\xi)</M> where <M>\eta : Q(G) \to Q(H)</M> and 
<M>\xi : [G,G] \to [H,H]</M> such that
<M>c_G * \xi = (\eta \times \eta) * c_H</M>. 
Isoclinism is an equivalence relation, and all abelian groups are isoclinic 
to the trivial group.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> G := SmallGroup( 64, 6 );
<pc group of size 64 with 6 generators>
gap> Q := CentralQuotient( G );
Group([ f1, f2, f3, <identity> of ..., <identity> of ..., <identity> of ... ])
gap> H := SmallGroup( 32, 41 );
<pc group of size 32 with 5 generators>
gap> iso := Isoclinism( G, H );
[ [ f1, f2, f3, <identity> of ..., <identity> of ..., <identity> of ... ] -> 
    [ f1, f2*f3, f3, <identity> of ..., <identity> of ..., <identity> of ... ]
    , [ f3, f5 ] -> [ f4*f5, f5 ] ]
gap> K := SmallGroup( 32, 43 );
<pc group of size 32 with 5 generators>
gap> AreIsoclinicGroups(G,K);
false
]]>
</Example>

<ManSection>
   <Prop Name="IsStemGroup"
         Arg="G" />
   <Oper Name="AllStemGroupIds"
         Arg="n" />
   <Oper Name="AllStemGroupFamilies"
         Arg="n" />
   <Attr Name="IsoclinicStemGroup"
         Arg="G" />
<Description>
A group <M>G</M> is a <E>stem group</E> if <M>Z(G) \leq [G,G]</M>. 
Every group is isoclinic to a stem group, but distinct stem groups 
may be isoclinic. 
For example, groups <M>D_8, Q_8</M> are both stem groups but are isoclinic. 
<P/>
The function <C>IsoclinicStemGroup</C> returns a stem group 
isoclinic to <M>G</M>. 
The function <C>AllStemGroupIds</C> returns the <C>IdGroup</C> list 
of the stem groups of a specified size, while <C>AllStemGroupFamilies</C> 
splits this list into isoclinism families.  
</Description>
</ManSection>
<Example>
<![CDATA[
gap> CommutatorSubgroup( G, G );
Group([ f3, f5 ])
gap> IsStemGroup( G );
false
gap> IsoclinicStemGroup( G );
<pc group of size 16 with 4 generators>
gap> IdGroup( last );
[ 16, 7 ]
gap> AllStemGroupIds( 32 );
[ [ 32, 6 ], [ 32, 7 ], [ 32, 8 ], [ 32, 18 ], [ 32, 19 ], [ 32, 20 ], 
  [ 32, 27 ], [ 32, 28 ], [ 32, 29 ], [ 32, 30 ], [ 32, 31 ], [ 32, 32 ], 
  [ 32, 33 ], [ 32, 34 ], [ 32, 35 ], [ 32, 43 ], [ 32, 44 ], [ 32, 49 ], 
  [ 32, 50 ] ]
gap> AllStemGroupFamilies( 32 );
[ [ [ 32, 6 ], [ 32, 7 ], [ 32, 8 ] ], [ [ 32, 18 ], [ 32, 19 ], [ 32, 20 ] ],
  [ [ 32, 27 ], [ 32, 28 ], [ 32, 29 ], [ 32, 30 ], [ 32, 31 ], [ 32, 32 ], 
      [ 32, 33 ], [ 32, 34 ], [ 32, 35 ] ], [ [ 32, 43 ], [ 32, 44 ] ], 
  [ [ 32, 49 ], [ 32, 50 ] ] ]
]]>
</Example>

<ManSection>
   <Attr Name="MiddleLength"
         Arg="G" />
   <Attr Name="RankXMod"
         Arg="X0" />
<Description>
Let <M>G</M> be a finite group. 
Then <M>\log_2 |[G,G] / (Z(G) \cap [G,G])|</M> is called the 
<E>middle length</E> of <M>G</M>. 
Also <M>\log_2 |Z(G) \cap [G,G]| + \log_2 |G/Z(G)|</M> 
is called the <E>rank</E> of <M>G</M>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> MiddleLength(G);
1.
gap> RankXMod(X1);
[ 2.32193, 2. ]
]]>
</Example>


</Section>


<Section><Heading>Isoclinism of Crossed Modules</Heading>

<ManSection>
   <Oper Name="AreIsoclinicXMods"
         Arg="X0 X1" />
<Description>
to follow
</Description>
</ManSection>
<Example>
<![CDATA[
gap> CentralQuotient(X5);            
[Group( [ f1^2, f1 ] )->Group( [ f1, f2, f3^2, f3 ] )]
gap> CentralQuotientHomomorphism(X5);
[[..] => [..]]

]]>
</Example>
</Section>


</Chapter>
