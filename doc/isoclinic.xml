<!-- ------------------------------------------------------------------- -->
<!--                                                                     -->
<!--  isoclinic.xml          XMod documentation            Alper Odabas  -->
<!--                                                       & Enver Uslu  -->
<!--  version 2.43, 04/11/2015                                           --> 
<!--                                                                     --> 
<!--  Copyright (C) 2001-2015, Chris Wensley et al                       --> 
<!--                                                                     -->
<!-- ------------------------------------------------------------------- -->

<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="chap-isclnc">
<Heading>Isoclinism of Crossed Modules</Heading>

This chapter describes some functions written by Alper Odaba&#x15f; and  
Enver Uslu, and reported in their paper <Cite Key="OUI1" />. 
Section <Ref Sect="sect-more-xmod-ops" /> contains some additional 
basic functions for crossed modules, 
constructing quotients, centres, centralizers and normalizers.
In Sections <Ref Sect="sect-isoclinic-groups" /> and 
<Ref Sect="sect-isoclinic-xmods" /> 
there are functions dealing specifically with isoclinism 
for groups and for crossed modules. 
Since these functions represent a recent addition to the package 
(as of November 2015), 
the function names are liable to change in future versions.

<Section Label="sect-more-xmod-ops">
<Heading>More operations for crossed modules</Heading>

<ManSection>
   <Oper Name="FactorXMod"
         Arg="X1 X2" />
   <Oper Name="NaturalMorphismByNormalSubXMod"
         Arg="X1 X2" />
<Description>
When <M>\mathcal{X}_2 = (\partial_2 : S_2 \to R_2)</M> 
is a normal subcrossed module of 
<M>\mathcal{X}_1 = (\partial_1 : S_1 \to R_1)</M>, 
then the quotient crossed module is 
<M>(\partial : S_2/S_1 \to R_2/R_1)</M>
with the induced boundary and action maps. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> D24 := DihedralGroup(24);;  SetName( D24, "D24" );
gap> X24 := XModByAutomorphismGroup( D24 );; 
gap> Size(X24);
[ 24, 48 ]
gap> nsx := NormalSubXMods( X24 );; 
gap> ids := List( nsx, n -> IdGroup(n) );; 
gap> pos1 := Position( ids, [ [4,1], [8,3] ] );;
gap> Xn1 := nsx[pos1];  Size( Xn1 );
[Group( [ f2*f4^2, f3*f4 ] )->Group( [ f3, f4, f5 ] )]
[ 4, 8 ]
gap> natn := NaturalMorphismByNormalSubXMod( X24, Xn1 ); 
[[D24->PAut(D24)] => [..]]
gap> Qn1 := FactorXMod( X24, Xn1 );  Size( Qn1 );
[Group( [ f1, f2, f2^2, f2 ] )->Group( 
[ f1, f2, <identity> of ..., <identity> of ..., <identity> of ... ] )]
[ 6, 6 ]
gap> nat1 := NaturalMorphismByNormalSubXMod( X24, Xn1 ); 
[[D24->PAut(D24)] => [..]]
]]>
</Example>

<ManSection>
   <Oper Name="IntersectionSubXMods"
         Arg="X0 X1 X2" />
<Description>
When <C>X1,X2</C> are subcrossed modules of <C>X0</C>, 
then the source and range of their intersection are the intersections 
of the sources and ranges of <C>X1</C> and <C>X2</C> respectively. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> pos2 := Position( ids, [ [24,6], [12,4] ] );;
gap> Xn2 := nsx[pos2]; 
[D24->Group( [ f1*f3, f2, f5 ] )]
gap> pos3 := Position( ids, [ [12,2], [24,5] ] );;
gap> Xn3 := nsx[pos3]; 
[Group( [ f2, f3, f4 ] )->Group( [ f1, f2, f4, f5 ] )]
gap> Xn23 := IntersectionSubXMods( X24, Xn2, Xn3 );
[Group( [ f2, f3, f4 ] )->Group( [ f2, f5, f2^2, f2*f5, f2^2*f5 ] )]
gap> [ Size(Xn2), Size(Xn3), Size(Xn23) ];
[ [ 24, 12 ], [ 12, 24 ], [ 12, 6 ] ]
]]>
</Example>

<ManSection>
   <Oper Name="Displacement"
         Arg="alpha r s" />
   <Attr Name="DisplacementSubgroup"
         Arg="X0" />
<Description> 
Commutators may be written 
<M>[r,q] = r^{-1}q^{-1}rq = (q^{-1})^rq = r^{-1}r^q</M>, 
and satisfy identities 
<Display> 
[r,q]^p = [r^p,q^p], \qquad 
[pr,q] = [p,q]^r[r,q], \qquad 
[r,pq] = [r,q][r,p]^q, \qquad 
[r,q]^{-1} = [q,r]. 
</Display> 
In a similar way, when a group <M>R</M> acts on a group <M>S</M>, 
the <E>displacement</E> of <M>s \in S</M> by <M>r \in R</M> 
is defined to be <M>\langle r,s \rangle := (s^{-1})^rs \in S</M>. 
When <M>\mathcal{X} = (\partial : S \to R)</M> is a pre-crossed module, 
the first crossed module axiom requires 
<M>\partial\langle r,s \rangle = [r,\partial s]</M>. 
For a given action <M>\alpha</M> the <C>Displacement</C> function 
may be used to calculate <M>\langle r,s \rangle</M>. 
Displacements satisfy the following identities, 
where <M>s,t \in S,~ p,q,r \in R</M>:  
<Display>
\langle r,s \rangle^p = \langle r^p,s^p \rangle, \qquad 
\langle qr,s \rangle = \langle q,s \rangle^r \langle r,s \rangle, \qquad 
\langle r,st \rangle = \langle r,t \rangle \langle r,s \rangle^t, \qquad 
\langle r,s \rangle^{-1} = \langle r^{-1},s^r \rangle. 
</Display> 
The <C>DisplacementSubgroup</C> of <M>\mathcal{X}</M> is the subgroup 
<M>&Disp;(\mathcal{X})</M> of <M>S</M> generated by these displacements. 
The identities imply  
<M>\langle r,s \rangle^t = 
   \langle r,st^{r^{-1}} \rangle \langle r^{-1},t \rangle</M>, 
so <M>&Disp;(\mathcal{X})</M> is normal in <M>S</M>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> pos4 := Position( ids, [ [6,2], [24,14] ] );;
gap> Xn4 := nsx[pos4];; 
gap> Sn4 := Source(Xn4);;  SetName( Sn4, "c6" ); 
gap> Rn4 := Range(Xn4);;  SetName( Rn4, "c2c2s3" );
gap> Display(Xn4);

Crossed module [c6->c2c2s3] :- 
: Source group has generators:
  [ f3, f4 ]
: Range group has generators:
  [ f1, f2, f3, f5 ]
: Boundary homomorphism maps source generators to:
  [ f2^2, f2 ]
: Action homomorphism maps range generators to automorphisms:
  f1 --> { source gens --> [ f3*f4^2, f4^2 ] }
  f2 --> { source gens --> [ f3, f4 ] }
  f3 --> { source gens --> [ f3, f4 ] }
  f5 --> { source gens --> [ f3, f4 ] }
  These 4 automorphisms generate the group of automorphisms.

gap> r := Rn4.1;;  s := Sn4.1;; 
gap> d := Displacement( XModAction(Xn4), r, s );
f4
gap> bn4 := Boundary( Xn4 );;
gap> Image( bn4, d ) = Comm( r, Image( bn4, s ) );  
true
gap> DisplacementSubgroup( Xn4 );
Group([ f4 ])
]]>
</Example>

<ManSection>
   <Oper Name="CommutatorSubXMod"
         Arg="X X1 X2" />
   <Oper Name="CrossActionSubgroup"
         Arg="X X1 X2" />
<Description>
When <M>\mathcal{X}_1 = (N \to Q), \mathcal{X}_2 = (M \to P)</M> 
are two normal subcrossed modules of <M>\mathcal{X} = (\partial : S \to R)</M>, 
the displacements <M>\langle p,n \rangle</M> and <M>\langle q,m \rangle</M> 
all map by <M>\partial</M> into <M>[Q,P]</M>. 
These displacements form a normal subgroup of <M>S</M>, 
called the <C>CrossActionSubgroup</C>. 
The <C>CommutatorSubXMod</C> <M>[\mathcal{X}_1,\mathcal{X}_2]</M> 
has this subgroup as source and <M>[P,Q]</M> as range, 
and is normal in <M>\mathcal{X}</M>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Cn23 := CommutatorSubXMod( X24, Xn2, Xn3 );
[Group( [ f2 ] )->Group( [ f2, f5 ] )]
gap> Size(Cn23);
[ 12, 6 ]
gap> Xn23 = Cn23;
true
gap> Q24 := CentralQuotient( D24) ;                     
[D24->Group( [ f1, f2, f3 ] )]
]]>
</Example>

<ManSection>
   <Attr Name="DerivedSubXMod"
         Arg="X0" />
<Description>
The <C>DerivedSubXMod</C> of <M>\mathcal{X}</M> is the normal subcrossed module 
<M>[\mathcal{X},\mathcal{X}] = (\partial' : &Disp;(\mathcal{X}) \to [R,R])</M> 
where <M>\partial'</M> is the restriction of <M>\partial</M>. 
<P/> 
This constructions is described on page 19 or 66 ??? of Norrie's thesis 
<Cite Key="N2" />. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> DXn4 := DerivedSubXMod( Xn4 );  
[Group( [ f4 ] )->Group( [ f2 ] )]
]]>
</Example>

<ManSection>
   <Oper Name="FixedPointSubgroupXMod"
         Arg="X0 T Q" />
   <Oper Name="StabilizerSubgroupXMod"
         Arg="X0 T Q" />
<Description>
The <C>FixedPointSubgroupXMod(X,T,Q)</C> 
for <M>\mathcal{X}=(\partial : S \to R)</M> is the subgroup 
<M>&Fix;(\mathcal{X},T,Q)</M> 
of elements <M>t \in T \leqslant S</M> individually fixed 
under the action of <M>Q \leqslant R</M>. 
<P/>
The <C>StabilizerSubgroupXMod(X,T,Q)</C> for <M>\mathcal{X}</M> 
is the subgroup <M>&Stab;(\mathcal{X},T,Q)</M> of <M>Q \leqslant R</M> 
whose elements act trivially on the whole of <M>T \leqslant S</M>. 
<P/>
These constructions are described on pages 19 or 66 ??? of Norrie's thesis 
<Cite Key="N2" />. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> fix := FixedPointSubgroupXMod( Xn4, Sn4, Rn4 );
Group([ f3*f4 ])
gap> stab := StabilizerSubgroupXMod( Xn4, Sn4, Rn4 );
Group([ f5, f2*f3 ])
]]>
</Example>

<ManSection Label="CentreXMod">
   <Attr Name="CentreXMod"
         Arg="X0" />
   <Oper Name="Centralizer"
         Arg="X Y" />
   <Oper Name="Normalizer"
         Arg="X Y" />
<Description>
The <E>centre</E> <M>Z(\mathcal{X})</M>   
of <M>\mathcal{X} = (\partial : S \to R)</M> 
has as source the fixed point subgroup <M>&Fix;(\mathcal{X},S,R)</M>. 
The range is the intersection of the centre <M>Z(R)</M>
with the stabilizer subgroup. 
<P/> 
When <M>\mathcal{Y} = (T \to Q)</M> is a subcrossed module of 
<M>\mathcal{X} = (\partial : S \to R)</M>, the <E>centralizer</E> 
<M>C_{\mathcal{X}}(\mathcal{Y})</M> of <M>\mathcal{Y}</M> 
has as source the fixed point subgroup <M>&Fix;(\mathcal{X},S,Q)</M>. 
The range is the intersection of the centralizer <M>C_R(Q)</M> 
with <M>&Stab;(\mathcal{X},T,R)</M>. 
<P/>
The <E>normalizer</E> <M>N_{\mathcal{X}}(\mathcal{Y})</M> 
of <M>\mathcal{Y}</M> has as source the subgroup of <M>S</M> 
consisting of the displacements <M>\langle s,q \rangle</M> 
which lie in <M>S</M>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> ZXn4 := CentreXMod( Xn4 );      
[Group( [ f3*f4 ] )->Group( [ f3, f5 ] )]
gap> IdGroup( ZXn4 );
[ [ 2, 1 ], [ 4, 2 ] ]
gap> CDXn4 := Centralizer( Xn4, DXn4 );
[Group( [ f3*f4 ] )->Group( [ f2 ] )]
gap> IdGroup( CDXn4 );    
[ [ 2, 1 ], [ 3, 1 ] ]
gap> NDXn4 := Normalizer( Xn4, DXn4 ); 
[Group( <identity> of ... )->Group( [ f5, f2*f3 ] )]
gap> IdGroup( NDXn4 );
[ [ 1, 1 ], [ 12, 5 ] ]
]>
</Example>

<ManSection>
   <Attr Name="CentralQuotient"
         Arg="G" /> 
<Description>
The <C>CentralQuotient</C> of a group <M>G</M> is the crossed module 
<M>(G \to G/Z(G))</M> 
with the natural homomorphism as the boundary map. 
This is a special case of <C>XModByCentralExtension</C> 
(see <Ref Sect="sect-constructions"/>). 
<P/>
Similarly, the central quotient of a crossed module 
<M>\mathcal{X}</M> is the crossed square 
<M>(\mathcal{X} \Rightarrow \mathcal{X}/Z(\mathcal{X})</M> 
(see section <Ref Sect="crossed square constructions"/>). 
The right-hand-side crossed module is the quotient of <M>\mathcal{X}</M> 
by its centre ???  
</Description>
</ManSection>
<Example>
<![CDATA[
gap> Q24 := CentralQuotient( D24);  Size( Q24 );                     
[D24->Group( [ f1, f2, f3 ] )]
[ 24, 12 ]
gap> N7 := nsx[7];;  IdGroup( N7 );
[ [ 12, 2 ], [ 24, 5 ] ]
gap> IdGroup( CentreXMod(N7) );  
[ [ 4, 1 ], [ 4, 1 ] ]
gap> CQN7 := CentralQuotient( N7 );
crossed square with:
      up = [Group( [ f2, f3, f4 ] )->Group( [ f1, f1^2, f1 ] )]
    left = [Group( [ f2, f3, f4 ] )->Group( [ f1, f2, f4, f5 ] )]
    down = [Group( [ f1, f2, f4, f5 ] )->Group( 
[ f1, f2, <identity> of ..., <identity> of ... ] )]
   right = [Group( [ f1, f1^2, f1 ] )->Group( 
[ f1, f2, <identity> of ..., <identity> of ... ] )]

gap> IdGroup( CQN7 );
[ [ [ 12, 2 ], [ 3, 1 ] ], [ [ 24, 5 ], [ 6, 1 ] ] ]
]]>
</Example>

<ManSection>
   <Prop Name="IsAbelian2dGroup"
         Arg="X0" />
   <Prop Name="IsAspherical2dGroup"
         Arg="X0" />
   <Prop Name="IsSimplyConnected2dGroup"
         Arg="X0" />
   <Prop Name="IsFaithful2dGroup"
         Arg="X0" />
<Description>
Need some description here.
</Description>
</ManSection>
<Example>
<![CDATA[
gap> [ IsAbelian2dGroup(Xn4), IsAbelian2dGroup(X24) ];
[ false, false ]
gap> pos7 := Position( ids, [ [3,1], [6,1] ] );;
gap> [ IsAspherical2dGroup(nsx[pos7]), IsAspherical2dGroup(X24) ];
[ true, false ]
gap> [ IsSimplyConnected2dGroup(Xn4), IsSimplyConnected2dGroup(X24) ];
[ true, true ]
gap> [ IsFaithful2dGroup(Xn4), IsFaithful2dGroup(X24) ];              
[ false, true ] 
]]>
</Example>

<ManSection>
   <Prop Name="IsNilpotent2dGroup"
         Arg="X0" />
   <Attr Name="NilpotencyClass2dGroup"
         Arg="X0" />
   <Attr Name="LowerCentralSeriesOfXMod"
         Arg="X0" />
<Description>
The <E>lower central series</E> of <M>\mathcal{X} = (\partial : S \to R)</M> 
is the sequence (see <Cite Key="N2" />): 
<Display>
\mathcal{X} ~=~ \Gamma_1(\mathcal{X}) ~\unrhd~ \Gamma_2(\mathcal{X}) 
              ~\unrhd~ \cdots 
\qquad \mbox{where} \qquad  
\Gamma_j(\mathcal{X}) ~=~ [ \Gamma_{j-1}(\mathcal{X}), \mathcal{X}].
</Display> 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> C8 := Cat1(16,8,1);
[QD16=>Group( [ f2, f2 ] )]
gap> X8 := XMod(C8); 
[Group( [ f1*f2*f3, f3, f4 ] )->Group( [ f2, f2 ] )]
gap> IdGroup( X8 );
[ [ 8, 1 ], [ 2, 1 ] ]
gap> ZX8 := CentreXMod( X8 );
[Group( [ f4 ] )->Group( <identity> of ... )]
gap> FX8 := FactorXMod( X8, ZX8 );
[Group( [ f1, f2, <identity> of ... ] )->Group( [ f2, f2 ] )]
gap> DX8 := DerivedSubXMod( X8 );
[Group( [ f3 ] )->Group( <identity> of ... )]
gap> RankXMod( X8 );  
[ 3., 1. ]
gap> MiddleLength( X8 );    
[ 1., 0. ]
gap> LowerCentralSeries(X8);
[ [Group( [ f1*f2*f3, f3, f4 ] )->Group( [ f2, f2 ] )], 
  [Group( [ f3 ] )->Group( <identity> of ... )], 
  [Group( [ f4 ] )->Group( <identity> of ... )], 
  [Group( <identity> of ... )->Group( <identity> of ... )] ]
]]>
</Example>

<ManSection>
   <Func Name="AllXMods"
         Arg="args" />
<Description>
The global function <C>AllXMods</C> may be called 
as <C>AllXMods(S,R)</C> to compute all crossed modules with chosen 
source and range groups; 
as <C>AllXMods([n,m])</C> to compute all crossed modules with a given size; 
or as <C>AllXMods(ord)</C> to compute all crossed modules whose associated 
cat1-groups have a given size <C>ord</C>. 
<P/> 
In the example we see that there are <M>4</M> crossed modules 
<M>(C_6 \to S_3)</M>; forming a subset of the <M>17</M> crossed modules 
with size <C>[6,6]</C>; and that these form a subset of the <M>205</M> 
crossed modules whose cat1-group has size <M>36</M>. 
There are <M>40</M> precrossed modules with size <C>[6,6]</C>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> xc6s3 := AllXMods( SmallGroup(6,2), SmallGroup(6,1) );;   
gap> Length( xc6s3 );           
4
gap> x66 := AllXMods( [6,6] );;   
gap> Length( x66 );
17
gap> x36 := AllXMods( 36 );; 
gap> Length( all36 ); 
205
]]>
</Example>

<ManSection>
   <Oper Name="IsomorphismXMods"
         Arg="X1 X2" />
<Description>
This function computes an isomorphism 
<M>\mu : \mathcal{X}_1 \to \mathcal{X}_2</M>, 
provided one exists, or else returns <C>fail</C>. 
The calculation in the example below shows that the <M>17</M> crossed modules 
of size <C>[6,6]</C> in <C>x66</C> (see the previous subsection) 
fall into <M>9</M> isomorphism classes. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> IsomorphismXMods( x66[1], x66[2] );
[[Group( [ f1, f2 ] )->Group( [ f1, f2 ] )] => [Group( [ f1, f2 ] )->Group( 
[ f1, f2 ] )]]
gap> L := ListWithIdenticalEntries( 17, 1 );;
gap> for i in [1..16] do 
>      if ( L[i] = 1 ) then 
>        X1 := x66[i]; 
>        for j in [i+1..17] do 
>          if ( L[j] = 1 ) then 
>            X2 := x66[j];            
>            mor := IsomorphismXMods( X1, X2 ); 
>            if ( mor <> fail ) then L[j]:=0; fi; 
>          fi;
>        od;
>      fi;
>    od;
gap> L;
[ 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0 ]
gap> Sum( L );
9
]]>
</Example>

The <M>60</M> crossed modules with source and range of size <M>4</M> 
retured by <C>AllXMods([4,4]);</C> form <M>18</M> isomorphism classes. 
<Example>
<![CDATA[
gap> all44 := AllXMods( [4,4] );; 
gap> Length( last );
60
gap> iso44 := AllXModsUpToIsomorphism( all44 );;
gap> Length( last );
18 
gap> L := ListWithIdenticalEntries( 60, 1 );;
gap> for i in [1..59] do 
>      if ( L[i] = 1 ) then 
>        L[i] := [i]; 
>        Y1 := all44[i]; 
>        for j in [i+1..60] do 
>          if ( L[j] = 1 ) then 
>            Y2 := all44[j];            
>            mor := IsomorphismXMods( Y1, Y2 ); 
>            if ( mor <> fail ) then 
>              L[j]:=0; 
>              Add( L[i], j );
>            fi; 
>          fi;
>        od;
>      fi;
>    od;
gap> L := Filtered( L, k -> k<>0 );
[ [ 1 ], [ 2 ], [ 3, 6 ], [ 4 ], [ 5 ], [ 7 ], [ 8, 9, 10 ], [ 11, 13, 15 ], 
  [ 12, 14, 16 ], [ 17 ], [ 18, 19, 20 ], [ 21, 23, 25 ], [ 22, 24, 26 ], 
  [ 27 ], [ 28, 29, 30, 31, 32, 33, 34, 35, 36 ], 
  [ 37, 39, 41, 43, 45, 49, 52, 55, 59 ], 
  [ 38, 40, 42, 44, 46, 50, 53, 56, 60 ], [ 47, 48, 51, 54, 57, 58 ] ]
]]>
</Example>




</Section>



<Section Label="sect-isoclinic-groups">
<Heading>Isoclinism of Groups</Heading>

<ManSection>
   <Oper Name="AreIsoclinicGroups"
         Arg="G H" />
   <Oper Name="Isoclinism"
         Arg="G H" />
<Description>
Let <M>G,H</M> be groups with central quotients <M>Q(G)</M> and <M>Q(H)</M> 
and derived subgroups <M>[G,G]</M> and <M>[H,H]</M> respectively. 
Let <M>c_G : G/Z(G) \times G/Z(G) \to [G,G]</M> 
and <M>c_H : H/Z(H) \times H/Z(H) \to [H,H]</M> be the two commutator maps.  
An <E>isoclinism</E> <M>G \sim H</M> is a pair of isomorphisms 
<M>(\eta,\xi)</M> where <M>\eta : G/Z(G) \to H/Z(H)</M> and 
<M>\xi : [G,G] \to [H,H]</M> such that
<M>c_G * \xi = (\eta \times \eta) * c_H</M>. 
Isoclinism is an equivalence relation, and all abelian groups are isoclinic 
to the trivial group.
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> G := SmallGroup( 64, 6 );;  StructureDescription( G ); 
"(C8 x C4) : C2"
gap> Q := CentralQuotient( G );;  IdGroup( Q );
[ [ 64, 6 ], [ 8, 3 ] ]
gap> H := SmallGroup( 32, 41 );;  StructureDescription( H );
"C2 x Q16"
gap> IdGroup( CentralQuotient( H ) );
[ [ 32, 41 ], [ 8, 3 ] ]
gap> Isoclinism( G, H );
[ [ f1, f2, f3 ] -> [ f1, f2*f3, f3 ], [ f3, f5 ] -> [ f4*f5, f5 ] ]
gap> K := SmallGroup( 32, 43 );;  StructureDescription( K );
"(C2 x D8) : C2"
gap> IdGroup( CentralQuotient( K ) );                       
[ [ 32, 43 ], [ 16, 11 ] ]
gap> AreIsoclinicDomains( G, K );
false
]]>
</Example>


<ManSection>
   <Prop Name="IsStemGroup"
         Arg="G" />
   <Attr Name="IsoclinicStemGroup"
         Arg="G" />
   <Oper Name="AllStemGroupIds"
         Arg="n" />
   <Oper Name="AllStemGroupFamilies"
         Arg="n" />
<Description>
A group <M>G</M> is a <E>stem group</E> if <M>Z(G) \leq [G,G]</M>. 
Every group is isoclinic to a stem group, but distinct stem groups 
may be isoclinic. 
For example, groups <M>D_8, Q_8</M> are both stem groups but are isoclinic. 
<P/>
The function <C>IsoclinicStemGroup</C> returns a stem group 
isoclinic to <M>G</M>. 
The function <C>AllStemGroupIds</C> returns the <C>IdGroup</C> list 
of the stem groups of a specified size, while <C>AllStemGroupFamilies</C> 
splits this list into isoclinism families.  
</Description>
</ManSection>
<Example>
<![CDATA[
gap> DerivedSubgroup(G);     
Group([ f3, f5 ])
gap> IsStemGroup( G );
false
gap> IsoclinicStemGroup( G );
<pc group of size 16 with 4 generators>
gap> IdGroup( last );
[ 16, 7 ]
gap> AllStemGroupIds( 32 );
[ [ 32, 6 ], [ 32, 7 ], [ 32, 8 ], [ 32, 18 ], [ 32, 19 ], [ 32, 20 ], 
  [ 32, 27 ], [ 32, 28 ], [ 32, 29 ], [ 32, 30 ], [ 32, 31 ], [ 32, 32 ], 
  [ 32, 33 ], [ 32, 34 ], [ 32, 35 ], [ 32, 43 ], [ 32, 44 ], [ 32, 49 ], 
  [ 32, 50 ] ]
gap> AllStemGroupFamilies( 32 );
[ [ [ 32, 6 ], [ 32, 7 ], [ 32, 8 ] ], [ [ 32, 18 ], [ 32, 19 ], [ 32, 20 ] ],
  [ [ 32, 27 ], [ 32, 28 ], [ 32, 29 ], [ 32, 30 ], [ 32, 31 ], [ 32, 32 ], 
      [ 32, 33 ], [ 32, 34 ], [ 32, 35 ] ], [ [ 32, 43 ], [ 32, 44 ] ], 
  [ [ 32, 49 ], [ 32, 50 ] ] ]
]]>
</Example>

<ManSection>
   <Attr Name="MiddleLength"
         Arg="G" />
   <Attr Name="RankXMod"
         Arg="X0" />
<Description>
Let <M>G</M> be a finite group. 
Then <M>\log_2 |[G,G] / (Z(G) \cap [G,G])|</M> is called the 
<E>middle length</E> of <M>G</M>. 
Also <M>\log_2 |Z(G) \cap [G,G]| + \log_2 |G/Z(G)|</M> 
is called the <E>rank</E> of <M>G</M>. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> MiddleLength(G);
1.
gap> RankXMod(X1);
[ 2.32193, 2. ]
]]>
</Example>


</Section>


<Section Label="sect-isoclinic-xmods">
<Heading>Isoclinism of Crossed Modules</Heading>

<ManSection>
   <Oper Name="Isoclinism"
         Arg="X0 Y0" />
<Description>
Let <M>\mathcal{X},\mathcal{Y}</M> be crossed modules with central quotients 
<M>Q(\mathcal{X})</M> and <M> Q(\mathcal{Y})</M>,  
and derived subcrossed modules <M>[\mathcal{X},\mathcal{X}]</M> 
and <M>[\mathcal{Y},\mathcal{Y}]</M> respectively. 
Let <M>c_\mathcal{X} : Q(\mathcal{X}) \times Q(\mathcal{X}) 
                    \to [\mathcal{X},\mathcal{X}]</M> 
and <M>c_\mathcal{Y} : Q(\mathcal{Y}) \times Q(\mathcal{Y}) 
                    \to [\mathcal{Y},\mathcal{Y}]</M> 
be the two commutator maps.  
An <E>isoclinism</E> <M>\mathcal{X} \sim \mathcal{Y}</M> 
is a pair of bijective morphisms 
<M>(\eta,\xi)</M> where <M>\eta : Q(\mathcal{X}) \to Q(\mathcal{Y})</M> 
and <M>\xi : [\mathcal{X},\mathcal{X}] \to [\mathcal{Y},\mathcal{Y}]</M> 
such that
<M>c_\mathcal{X} * \xi = (\eta \times \eta) * c_\mathcal{Y}</M>. 
Isoclinism is an equivalence relation, and all abelian crossed modules 
are isoclinic to the trivial crossed module. 
<P/>
</Description>
</ManSection>

Here is Example 6 from the paper (with <C>X1,X2</C> renumbdered <C>X8,X9</C>). 
<Example>
<![CDATA[
gap> C8 := Cat1(16,8,1);
[QD16=>Group( [ f2, f2 ] )]
gap> X8 := XMod(C8); 
[Group( [ f1*f2*f3, f3, f4 ] )->Group( [ f2, f2 ] )]
gap> IdGroup( X8 );
[ [ 8, 1 ], [ 2, 1 ] ]
gap> ZX8 := CentreXMod( X8 );
[Group( [ f4 ] )->Group( <identity> of ... )]
gap> FX8 := FactorXMod( X8, ZX8 );
[Group( [ f1, f2, <identity> of ... ] )->Group( [ f2, f2 ] )]
gap> DX8 := DerivedSubXMod( X8 );
[Group( [ f3*f4, f4 ] )->Group( <identity> of ... )]
gap> RankXMod( X8 );  
[ 3., 1. ]
gap> MiddleLength( X8 );    
[ 1., 0. ]
gap> LowerCentralSeries(X8);
[ [Group( [ f1*f2*f3, f3, f4 ] )->Group( [ f2, f2 ] )], 
  [Group( [ f3*f4, f4 ] )->Group( <identity> of ... )], 
  [Group( [ f4 ] )->Group( <identity> of ... )], 
  [Group( [ <identity> of ... ] )->Group( <identity> of ... )] ]

gap> C9 := Cat1(32,9,1);
[(C8 x C2) : C2=>Group( [ f2, f2 ] )]
gap> X9 := XMod( C9 );
[Group( [ f1*f2*f3, f3, f4, f5 ] )->Group( [ f2, f2 ] )]
gap> IdGroup( X9 );
[ [ 16, 5 ], [ 2, 1 ] ]
gap> ZX9 := CentreXMod( X9 );
[Group( [ f4, f5 ] )->Group( <identity> of ... )]
gap> FX9 := FactorXMod( X9, ZX9 );
[Group( [ f1, f2, <identity> of ..., <identity> of ... ] )->Group( 
[ f2, f2 ] )]
gap> DX9 := DerivedSubXMod( X9 );
[Group( [ f3*f5, f5 ] )->Group( <identity> of ... )]
gap> morF := IsomorphismXMods( FX8, FX9 );
[[Group( [ f1, f2, <identity> of ... ] )->Group( [ f2, f2 ] )] => [Group( 
[ f1, f2, <identity> of ..., <identity> of ... ] )->Group( [ f2, f2 ] )]]
gap> morD := IsomorphismXMods( DX8, DX9 );
[[Group( [ f3*f4, f4 ] )->Group( <identity> of ... )] => [Group( 
[ f3*f5, f5 ] )->Group( <identity> of ... )]]
gap> IsStemXMod(X8);
true
gap> IsStemXMod(X9);
false
gap> iso89 := Isoclinism( X8, X9 );;
gap> MappingGeneratorsImages( iso89[1] );
[ [ [ f1, f2, <identity> of ... ], [ f1*f2, f2, <identity> of ... ] ], 
  [ [ f2, f2 ], [ f2, f2 ] ] ]
gap> MappingGeneratorsImages( iso89[2] );
[ [ [ f3*f4, f4 ], [ f3, f5 ] ], [ [  ], [  ] ] ]
gap> XG := XMod(G);; 
gap> XH := XMod(H);;
gap> AreIsoclinicDomains( XG, XH );
true
]]>
</Example>

Here is Example 7 from the paper. 
<Example>
<![CDATA[
gap> all44 := AllXMods( [4,4] );;
gap> Length( all44 );            
60
gap> iso44 := AllXModsUpToIsomorphism( all44 );;
gap> Length( iso44 );
18
gap> IsoclinicXModFamily( iso44[1], iso44 );
[ 1, 3, 4, 6, 8, 10, 12, 14, 16, 18 ]
gap> IsoclinicXModFamily( iso44[2], iso44 );
[ 2, 5, 7, 9, 11, 13, 15, 17 ]
]]>
</Example>

<ManSection>
   <Prop Name="IsStemXMod"
         Arg="X0" />
<Description>
A crossed module <M>\mathcal{X}</M> is a <E>stem crossed module</E> 
if <M>Z(\mathcal{X}) \leq [\mathcal{X},\mathcal{X}]</M>. 
Every crossed module is isoclinic to a stem crossed module, 
but distinct stem crossed modules may be isoclinic. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> IsStemXMod(X8);
true
gap> IsStemXMod(X9);
false
]]>
</Example>



</Section>


</Chapter>
