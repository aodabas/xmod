<!-- ------------------------------------------------------------------- -->
<!--                                                                     -->
<!--  gp2ind.xml            XMod documentation            Chris Wensley  -->
<!--                                                        & Murat Alp  -->
<!--  Copyright (C) 2001-2018, Chris Wensley et al,                      --> 
<!--  School of Computer Science, Bangor University, U.K.                --> 
<!--                                                                     -->
<!-- ------------------------------------------------------------------- -->

<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="chap-gp2ind">
<Heading>Induced constructions</Heading>

Before describing general functions for computing induced structures, 
we consider coproducts of crossed modules which provide induced 
crossed modules in certain cases. 


<Section><Heading>Coproducts of crossed modules</Heading>

Need to add here a reference (or two) for coproducts. 

<ManSection>
   <Oper Name="CoproductXMod"
         Arg="X1, X2" />
   <Attr Name="CoproductInfo"
         Arg="X0" />
<Description>
This function calculates the coproduct crossed module of
crossed modules <M>{\mathcal X}_1 = (\partial_1 : S_1 \to R)</M> 
and <M>{\mathcal X}_2 = (\partial_2 : S_2 \to R)</M> 
which have a common range <M>R</M>. 
The source <M>S_2</M> of <M>{\mathcal X}_2</M> acts on <M>S_1</M> 
via <M>\partial_2</M> and the action of <M>{\mathcal X}_1</M>, 
so we can form a precrossed module 
<M>(\partial' : S_2 \ltimes S_1 \to R)</M> 
where <M>\partial'(s_2,s_1) = (\partial_2 s_2)(\partial_1 s_1)</M>. 
The action of this precrossed module is the diagonal action 
<M>(s_2,s_1)^r = (s_2^r,s_1^r)</M>. 
Factoring out by the Peiffer subgroup, we obtain the coproduct 
crossed module <M>{\mathcal X}_1 \circ {\mathcal X}_2</M>. 
<P/>
In the example the structure descriptions of the precrossed module, 
the Peiffer subgroup, and the resulting coproduct are printed out 
when <C>InfoLevel(InfoXMod}</C> is at least <M>1</M>. 
The coproduct comes supplied with attribute <C>CoproductInfo</C>, 
which includes the embedding morphisms of the two factors. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> q8 := Group( (1,2,3,4)(5,8,7,6), (1,5,3,7)(2,6,4,8) );;
gap> X8 := XModByAutomorphismGroup( q8 );;
gap> s4b := Range( X8 );; 
gap> SetName( q8, "q8" );  SetName( s4b, "s4b" ); 
gap> a := q8.1;;  b := q8.2;; 
gap> alpha := GroupHomomorphismByImages( q8, q8, [a,b], [a^-1,b] );;
gap> beta := GroupHomomorphismByImages( q8, q8, [a,b], [a,b^-1] );;
gap> k4b := Subgroup( s4b, [ alpha, beta ] );;  SetName( k4b, "k4b" );
gap> Z8 := XModByNormalSubgroup( s4b, k4b );;
gap> SetName( X8, "X8" );  SetName( Z8, "Z8" );  
gap> SetInfoLevel( InfoXMod, 1 ); 
gap> XZ8 := CoproductXMod( X8, Z8 );
#I  prexmod is [ [ 32, 47 ], [ 24, 12 ] ]
#I  peiffer subgroup is C2, [ 2, 1 ]
#I  the coproduct is [ "C2 x C2 x C2 x C2", "S4" ], [ [ 16, 14 ], [ 24, 12 ] ]
[Group( [ f1, f2, f3, f4 ] )->s4b]
gap> SetName( XZ8, "XZ8" ); 
gap> info := CoproductInfo( XZ8 );
rec( embeddings := [ [X8 => XZ8], [Z8 => XZ8] ], xmods := [ X8, Z8 ] )
gap> SetInfoLevel( InfoXMod, 0 ); 
]]>
</Example>

</Section>


<Section><Heading>Induced crossed modules</Heading>
<Index>induced crossed module</Index>

A morphism of crossed modules
<M>(\sigma, \rho) : {\mathcal X}_1 \to {\mathcal X}_2</M>
factors uniquely through an induced crossed module
<M>\rho_{\ast} {\mathcal X}_1 = (\delta  :  \rho_{\ast} S_1 \to R_2)</M>.
Similarly, a morphism of cat1-groups factors through an induced cat1-group.
Calculation of induced crossed modules of <M>{\mathcal X}</M> also
provides an algebraic means of determining the homotopy <M>2</M>-type
of homotopy pushouts of the classifying space of <M>{\mathcal X}</M>.
For more background from algebraic topology see references in
<Cite Key="BH1" />, <Cite Key="BW1" />, <Cite Key="BW2" />.
Induced crossed modules and induced cat1-groups also provide the
building blocks for constructing pushouts in the categories
<E>XMod</E> and <E>Cat1</E>.
<P/>
Although the original aim of the &XMod; package was the calculation of 
induced crossed modules, there was for many years a requirement that 
<M>{\mathcal X}_1</M> be the inclusion of a normal subgroup. 
It was not until version 2.69 in July 2018 that this restriction 
was removed. 
<P/> 
The data for an induced crossed module comprises a crossed module 
<M>{\mathcal X} = (\partial : S \to R)</M> together with 
a homomorphism <M>\iota</M> from <M>R</M> to a third group <M>Q</M>. 
The output from the calculation is a crossed module
<M>\iota_{\ast}{\mathcal X} = (\delta : \iota_{\ast}S \to Q)</M>
together with a morphism of crossed modules
<M>{\mathcal X} \to \iota_{\ast}{\mathcal X}</M>.
Important special cases are when <M>\iota</M> 
is a surjection, and when <M>\iota</M> is a monomorphism. 
<P/> 
An induced computation should normally be called using the form 
<C>InducedXMod(X0,iota)</C>, and this global function will determine 
one or more special cases to be calculated.

<ManSection>
   <Oper Name="SurjectiveInducedXMod"
         Arg="xmod, hom" />
<Description>
When <M>\iota</M> is a surjection with kernel <M>K</M> then
<M>\iota_{\ast}S = S/\langle K,S\rangle </M> 
where <M>\langle K,S\rangle </M> is the 
<Ref Oper="DisplacementGroup"/> (see <Cite Key="BH1" />) 
determined by the data <M>[\mathcal{X}_1,K,S]</M>. 
(For many years, up until July 2018, this manual has stated the result to be 
<M>[K,S]</M>, even though the correct quotient was calculated.) 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> s4gens := GeneratorsOfGroup( s4 );
[ (1,2), (2,3), (3,4) ]
gap> a4gens := GeneratorsOfGroup( a4 );
[ (1,2,3), (2,3,4) ]
gap> s3b := Group( (5,6),(6,7) );;  SetName( s3b, "s3b" );
gap> epi := GroupHomomorphismByImages( s4, s3b, s4gens, [(5,6),(6,7),(5,6)] );;
gap> X4 := XModByNormalSubgroup( s4, a4 );;
gap> IX4a := SurjectiveInducedXMod( X4, epi );
[a4/ker->s3b]
gap> Display( IX4a );

Crossed module [a4/ker->s3b] :- 
: Source group a4/ker has generators:
  [ (1,3,2), (1,2,3) ]
: Range group s3b has generators:
  [ (5,6), (6,7) ]
: Boundary homomorphism maps source generators to:
  [ (5,6,7), (5,7,6) ]
: Action homomorphism maps range generators to automorphisms:
  (5,6) --> { source gens --> [ (1,2,3), (1,3,2) ] }
  (6,7) --> { source gens --> [ (1,2,3), (1,3,2) ] }
  These 2 automorphisms generate the group of automorphisms.
]]>
</Example>


<ManSection>
   <Oper Name="InjectiveInducedXMod"
         Arg="xmod, hom, list" />
<Description>
(This operations was named <C>InclusonInducedXModByCopower</C> 
until version 2.69 of July 2018.) 
When <M>\iota</M> is an inclusion, the induced crossed module may be
calculated using a copower <Cite Key="BW1" />.  
(Alternatively, when <M>R</M> is normal in <M>Q</M>, 
we may calculate a coproduct of crossed modules 
(<Cite Key="BW2" />, but this is not yet implemented).
<P/>
Here is a brief description of the copower construction. 
<List>
<Item>
  <M>X = (\mu : S \to R)</M> is a crossed module 
  and the homomorphism <M>\iota : R \to Q</M> is an injection. 
</Item>
<Item>
  <M>T</M> is a left/right common transversal of <M>\iota(R)</M> in <M>Q</M>. 
</Item>
<Item>
  <M>C = M \stackrel{*}{\to} T</M> is the copower: 
   the free product of groups <M>\{M_t : t \in T\}</M> 
   where <M>M_t = {(m,t) : m \in M}</M>, which is isomorphic to <M>M</M> 
   by <M>(m,t) \mapsto m</M>. 
</Item>
<Item> 
  <M>Q</M> acts on <M>C</M> by <M>(m,t)^q = (m^r,u)</M> 
  where <M>tq = (\iota r)u</M>. 
</Item>
<Item>
  The boundary map is <M>\delta : C \to Q</M>, 
  defined on generators by <M>(m,t) \mapsto t^{-1}(\iota \mu m)t</M>. 
</Item>
<Item>
  <M>\iota_*M = C/N</M> where <M>N</M> is the normal closure in <M>C</M> 
  of the Peiffer commutators  
  <Display>\langle(r,t),(s,u)\rangle 
           = (r,t)^{-1}(s,u)^{-1}(r,t)(s,u)^{\delta(r,t)}.
  </Display>
</Item>
</List>
This construction uses the Tietze transformation routines in 
the library file <C>tietze.gi</C>.
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> s5 := Group( (1,2,3,4,5), (4,5) );;
gap> SetName( s5, "s5" ); 
gap> inc45 := InclusionMappingGroups( s5, s4 );;
gap> IX4b := InjectiveInducedXMod( X4, inc45, [ ] );;
gap> StructureDescription( IX4b );
[ "GL(2,4)", "S5" ]
gap> Display( IX4b );

Crossed module i*([a4->s4]) :- 
: Source group has generators:
  [ ( 1, 2, 3)( 5, 8, 9)( 6,10,11)( 7,12,13), 
  ( 2, 4, 5)( 3, 6, 7)( 8,13,14)( 9,11,15) ]
: Range group s5 has generators:
  [ (1,2,3,4,5), (4,5) ]
: Boundary homomorphism maps source generators to:
  [ (2,4,3), (1,4,5) ]
: Action homomorphism maps range generators to automorphisms:
  (1,2,3,4,5) --> { source gens --> 
[ ( 1,12,10)( 2, 7,14)( 3, 4,11)( 6,15,13), 
  ( 1, 4, 9)( 2,11,13)( 5,12,14)( 8,10,15) ] }
  (4,5) --> { source gens --> [ ( 1,15, 3)( 4, 7,12)( 5, 9, 8)( 6,10,14), 
  ( 2, 5, 4)( 3, 7, 6)( 8,14,13)( 9,15,11) ] }
  These 2 automorphisms generate the group of automorphisms.
]]>
</Example>


<ManSection>
   <Func Name="InducedXMod"
         Arg="args" />
<Description>
When <M>\iota</M> is neither a surjection nor an inclusion, <M>\iota</M>
is factored as the composite of the surjection onto the image
and the inclusion of the image in <M>Q</M>, and then the composite induced
crossed module is constructed. 
In the example <C>iota45</C> is the composite of a surjection onto <M>S_3</M> 
followed by an inclusion in <M>S_5</M>. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> iota45 := GroupHomomorphismByImages( s4, s5, s4gens,                   
>                  [ (1,2), (2,3), (1,2) ] );; 
gap> IX4c := InducedXMod( X4, iota45 );
i*(i*([a4->s4]))
gap> StructureDescription( IX4c );
[ "C3 x SL(2,5)", "S5" ]
]]>
</Example> 

For another example, we use the alternative version <C>InducedXMod(Q,R,S)</C> 
of this global function, where <M>Q \geqslant R \geqslant S</M> are groups. 
We take the identity mapping on <C>s3c</C> as boundary,
and the inclusion of <C>s3c</C> in <C>s4</C> as <M>\iota</M>.
The induced group is a general linear group <C>GL(2,3)</C>.
<P/>
<Example>
<![CDATA[
gap> s3c := Subgroup( s4, [ (2,3), (3,4) ] );;  
gap> SetName( s3c, "s3c" );
gap> indXs3c := InducedXMod( s4, s3c, s3c );
#I induced group has Size: 48
i*([s3c->s3c])
gap> StructureDescription( indXs3c );
[ "GL(2,3)", "S4" ]
]]>
</Example>



<ManSection>
   <Prop Name="IsInducedXMod"
         Arg="xmod" />
<Description>
Crossed modules constructed by the above routines have this property 
set to <C>true</C>. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> IsInducedXMod( IX4b ); 
true
]]>
</Example>


<ManSection>
   <Attr Name="MorphismOfInducedXMod"
         Arg="xmod" />
<Description> 
This is the morphism of crossed modules from 
<M>\mathcal X</M> to <M>\iota_{\ast}{\mathcal X}</M>. 
In the example the morphism is the composite of the morphisms 
from the surjective and injective inductions. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> morIX4c := MorphismOfInducedXMod( IX4c );
[[a4->s4] => i*(i*([a4->s4]))]
]]>
</Example>

<ManSection>
   <Oper Name="AllInducedXMods"
         Arg="Q" />
<Description>
This function calculates all the induced crossed modules 
<C>InducedXMod(Q,R,S)</C>, 
where <C>R</C> runs over all conjugacy classes of subgroups of <C>Q</C> 
and <C>S</C> runs over all non-trivial subgroups of <C>R</C>.
</Description>
</ManSection>
<Example>
<![CDATA[
gap> all := AllInducedXMods( q8 );;
gap> ids := List( all, x -> IdGroup(x) );;
gap> Sort( ids );
gap> ids;
[ [ [ 1, 1 ], [ 8, 4 ] ], [ [ 1, 1 ], [ 8, 4 ] ], [ [ 1, 1 ], [ 8, 4 ] ], 
  [ [ 1, 1 ], [ 8, 4 ] ], [ [ 4, 2 ], [ 8, 4 ] ], [ [ 4, 2 ], [ 8, 4 ] ], 
  [ [ 4, 2 ], [ 8, 4 ] ], [ [ 16, 2 ], [ 8, 4 ] ], [ [ 16, 2 ], [ 8, 4 ] ], 
  [ [ 16, 2 ], [ 8, 4 ] ], [ [ 16, 14 ], [ 8, 4 ] ] ]
]]>
</Example>

</Section>

<Section><Heading>Induced cat<M>^1</M>-groups</Heading>
<Index>induced cat1-groups</Index>

<ManSection>
   <Func Name="InducedCat1Group"
         Arg="args" />
   <Prop Name="InducedCat1GroupByFreeProduct"
         Arg="grp, hom" />
<Description>
This area awaits development. 
</Description>
</ManSection>

</Section>

</Chapter>
